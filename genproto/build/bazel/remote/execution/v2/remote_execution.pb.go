// Code generated by protoc-gen-go. DO NOT EDIT.
// source: build/bazel/remote/execution/v2/remote_execution.proto

package remoteexecution

import (
	context "context"
	fmt "fmt"
	semver "github.com/buchgr/bazel-remote/genproto/build/bazel/semver"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	longrunning "google.golang.org/genproto/googleapis/longrunning"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ExecutionStage_Value int32

const (
	// Invalid value.
	ExecutionStage_UNKNOWN ExecutionStage_Value = 0
	// Checking the result against the cache.
	ExecutionStage_CACHE_CHECK ExecutionStage_Value = 1
	// Currently idle, awaiting a free machine to execute.
	ExecutionStage_QUEUED ExecutionStage_Value = 2
	// Currently being executed by a worker.
	ExecutionStage_EXECUTING ExecutionStage_Value = 3
	// Finished execution.
	ExecutionStage_COMPLETED ExecutionStage_Value = 4
)

var ExecutionStage_Value_name = map[int32]string{
	0: "UNKNOWN",
	1: "CACHE_CHECK",
	2: "QUEUED",
	3: "EXECUTING",
	4: "COMPLETED",
}

var ExecutionStage_Value_value = map[string]int32{
	"UNKNOWN":     0,
	"CACHE_CHECK": 1,
	"QUEUED":      2,
	"EXECUTING":   3,
	"COMPLETED":   4,
}

func (x ExecutionStage_Value) String() string {
	return proto.EnumName(ExecutionStage_Value_name, int32(x))
}

func (ExecutionStage_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{21, 0}
}

type DigestFunction_Value int32

const (
	// It is an error for the server to return this value.
	DigestFunction_UNKNOWN DigestFunction_Value = 0
	// The SHA-256 digest function.
	DigestFunction_SHA256 DigestFunction_Value = 1
	// The SHA-1 digest function.
	DigestFunction_SHA1 DigestFunction_Value = 2
	// The MD5 digest function.
	DigestFunction_MD5 DigestFunction_Value = 3
	// The Microsoft "VSO-Hash" paged SHA256 digest function.
	// See https://github.com/microsoft/BuildXL/blob/master/Documentation/Specs/PagedHash.md .
	DigestFunction_VSO DigestFunction_Value = 4
	// The SHA-384 digest function.
	DigestFunction_SHA384 DigestFunction_Value = 5
	// The SHA-512 digest function.
	DigestFunction_SHA512 DigestFunction_Value = 6
	// Murmur3 128-bit digest function, x64 variant. Note that this is not a
	// cryptographic hash function and its collision properties are not strongly guaranteed.
	// See https://github.com/aappleby/smhasher/wiki/MurmurHash3 .
	DigestFunction_MURMUR3 DigestFunction_Value = 7
)

var DigestFunction_Value_name = map[int32]string{
	0: "UNKNOWN",
	1: "SHA256",
	2: "SHA1",
	3: "MD5",
	4: "VSO",
	5: "SHA384",
	6: "SHA512",
	7: "MURMUR3",
}

var DigestFunction_Value_value = map[string]int32{
	"UNKNOWN": 0,
	"SHA256":  1,
	"SHA1":    2,
	"MD5":     3,
	"VSO":     4,
	"SHA384":  5,
	"SHA512":  6,
	"MURMUR3": 7,
}

func (x DigestFunction_Value) String() string {
	return proto.EnumName(DigestFunction_Value_name, int32(x))
}

func (DigestFunction_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{36, 0}
}

type SymlinkAbsolutePathStrategy_Value int32

const (
	// Invalid value.
	SymlinkAbsolutePathStrategy_UNKNOWN SymlinkAbsolutePathStrategy_Value = 0
	// Server will return an `INVALID_ARGUMENT` on input symlinks with absolute
	// targets.
	// If an action tries to create an output symlink with an absolute target, a
	// `FAILED_PRECONDITION` will be returned.
	SymlinkAbsolutePathStrategy_DISALLOWED SymlinkAbsolutePathStrategy_Value = 1
	// Server will allow symlink targets to escape the input root tree, possibly
	// resulting in non-hermetic builds.
	SymlinkAbsolutePathStrategy_ALLOWED SymlinkAbsolutePathStrategy_Value = 2
)

var SymlinkAbsolutePathStrategy_Value_name = map[int32]string{
	0: "UNKNOWN",
	1: "DISALLOWED",
	2: "ALLOWED",
}

var SymlinkAbsolutePathStrategy_Value_value = map[string]int32{
	"UNKNOWN":    0,
	"DISALLOWED": 1,
	"ALLOWED":    2,
}

func (x SymlinkAbsolutePathStrategy_Value) String() string {
	return proto.EnumName(SymlinkAbsolutePathStrategy_Value_name, int32(x))
}

func (SymlinkAbsolutePathStrategy_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{39, 0}
}

type Compressor_Value int32

const (
	// No compression. Servers and clients MUST always support this, and do
	// not need to advertise it.
	Compressor_IDENTITY Compressor_Value = 0
	// Zstandard compression.
	Compressor_ZSTD Compressor_Value = 1
)

var Compressor_Value_name = map[int32]string{
	0: "IDENTITY",
	1: "ZSTD",
}

var Compressor_Value_value = map[string]int32{
	"IDENTITY": 0,
	"ZSTD":     1,
}

func (x Compressor_Value) String() string {
	return proto.EnumName(Compressor_Value_name, int32(x))
}

func (Compressor_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{40, 0}
}

// An `Action` captures all the information about an execution which is required
// to reproduce it.
//
// `Action`s are the core component of the [Execution] service. A single
// `Action` represents a repeatable action that can be performed by the
// execution service. `Action`s can be succinctly identified by the digest of
// their wire format encoding and, once an `Action` has been executed, will be
// cached in the action cache. Future requests can then use the cached result
// rather than needing to run afresh.
//
// When a server completes execution of an
// [Action][build.bazel.remote.execution.v2.Action], it MAY choose to
// cache the [result][build.bazel.remote.execution.v2.ActionResult] in
// the [ActionCache][build.bazel.remote.execution.v2.ActionCache] unless
// `do_not_cache` is `true`. Clients SHOULD expect the server to do so. By
// default, future calls to
// [Execute][build.bazel.remote.execution.v2.Execution.Execute] the same
// `Action` will also serve their results from the cache. Clients must take care
// to understand the caching behaviour. Ideally, all `Action`s will be
// reproducible so that serving a result from cache is always desirable and
// correct.
type Action struct {
	// The digest of the [Command][build.bazel.remote.execution.v2.Command]
	// to run, which MUST be present in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	CommandDigest *Digest `protobuf:"bytes,1,opt,name=command_digest,json=commandDigest,proto3" json:"command_digest,omitempty"`
	// The digest of the root
	// [Directory][build.bazel.remote.execution.v2.Directory] for the input
	// files. The files in the directory tree are available in the correct
	// location on the build machine before the command is executed. The root
	// directory, as well as every subdirectory and content blob referred to, MUST
	// be in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	InputRootDigest *Digest `protobuf:"bytes,2,opt,name=input_root_digest,json=inputRootDigest,proto3" json:"input_root_digest,omitempty"`
	// A timeout after which the execution should be killed. If the timeout is
	// absent, then the client is specifying that the execution should continue
	// as long as the server will let it. The server SHOULD impose a timeout if
	// the client does not specify one, however, if the client does specify a
	// timeout that is longer than the server's maximum timeout, the server MUST
	// reject the request.
	//
	// The timeout is a part of the
	// [Action][build.bazel.remote.execution.v2.Action] message, and
	// therefore two `Actions` with different timeouts are different, even if they
	// are otherwise identical. This is because, if they were not, running an
	// `Action` with a lower timeout than is required might result in a cache hit
	// from an execution run with a longer timeout, hiding the fact that the
	// timeout is too short. By encoding it directly in the `Action`, a lower
	// timeout will result in a cache miss and the execution timeout will fail
	// immediately, rather than whenever the cache entry gets evicted.
	Timeout *duration.Duration `protobuf:"bytes,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// If true, then the `Action`'s result cannot be cached, and in-flight
	// requests for the same `Action` may not be merged.
	DoNotCache bool `protobuf:"varint,7,opt,name=do_not_cache,json=doNotCache,proto3" json:"do_not_cache,omitempty"`
	// An optional additional salt value used to place this `Action` into a
	// separate cache namespace from other instances having the same field
	// contents. This salt typically comes from operational configuration
	// specific to sources such as repo and service configuration,
	// and allows disowning an entire set of ActionResults that might have been
	// poisoned by buggy software or tool failures.
	Salt []byte `protobuf:"bytes,9,opt,name=salt,proto3" json:"salt,omitempty"`
	// The optional platform requirements for the execution environment. The
	// server MAY choose to execute the action on any worker satisfying the
	// requirements, so the client SHOULD ensure that running the action on any
	// such worker will have the same result.  A detailed lexicon for this can be
	// found in the accompanying platform.md.
	// New in version 2.2: clients SHOULD set these platform properties as well
	// as those in the [Command][build.bazel.remote.execution.v2.Command]. Servers
	// SHOULD prefer those set here.
	Platform             *Platform `protobuf:"bytes,10,opt,name=platform,proto3" json:"platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{0}
}

func (m *Action) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action.Unmarshal(m, b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return xxx_messageInfo_Action.Size(m)
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetCommandDigest() *Digest {
	if m != nil {
		return m.CommandDigest
	}
	return nil
}

func (m *Action) GetInputRootDigest() *Digest {
	if m != nil {
		return m.InputRootDigest
	}
	return nil
}

func (m *Action) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *Action) GetDoNotCache() bool {
	if m != nil {
		return m.DoNotCache
	}
	return false
}

func (m *Action) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *Action) GetPlatform() *Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

// A `Command` is the actual command executed by a worker running an
// [Action][build.bazel.remote.execution.v2.Action] and specifications of its
// environment.
//
// Except as otherwise required, the environment (such as which system
// libraries or binaries are available, and what filesystems are mounted where)
// is defined by and specific to the implementation of the remote execution API.
type Command struct {
	// The arguments to the command. The first argument must be the path to the
	// executable, which must be either a relative path, in which case it is
	// evaluated with respect to the input root, or an absolute path.
	Arguments []string `protobuf:"bytes,1,rep,name=arguments,proto3" json:"arguments,omitempty"`
	// The environment variables to set when running the program. The worker may
	// provide its own default environment variables; these defaults can be
	// overridden using this field. Additional variables can also be specified.
	//
	// In order to ensure that equivalent
	// [Command][build.bazel.remote.execution.v2.Command]s always hash to the same
	// value, the environment variables MUST be lexicographically sorted by name.
	// Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
	EnvironmentVariables []*Command_EnvironmentVariable `protobuf:"bytes,2,rep,name=environment_variables,json=environmentVariables,proto3" json:"environment_variables,omitempty"`
	// A list of the output files that the client expects to retrieve from the
	// action. Only the listed files, as well as directories listed in
	// `output_directories`, will be returned to the client as output.
	// Other files or directories that may be created during command execution
	// are discarded.
	//
	// The paths are relative to the working directory of the action execution.
	// The paths are specified using a single forward slash (`/`) as a path
	// separator, even if the execution platform natively uses a different
	// separator. The path MUST NOT include a trailing slash, nor a leading slash,
	// being a relative path.
	//
	// In order to ensure consistent hashing of the same Action, the output paths
	// MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
	// bytes).
	//
	// An output file cannot be duplicated, be a parent of another output file, or
	// have the same path as any of the listed output directories.
	//
	// Directories leading up to the output files are created by the worker prior
	// to execution, even if they are not explicitly part of the input root.
	//
	// DEPRECATED since v2.1: Use `output_paths` instead.
	OutputFiles []string `protobuf:"bytes,3,rep,name=output_files,json=outputFiles,proto3" json:"output_files,omitempty"`
	// A list of the output directories that the client expects to retrieve from
	// the action. Only the listed directories will be returned (an entire
	// directory structure will be returned as a
	// [Tree][build.bazel.remote.execution.v2.Tree] message digest, see
	// [OutputDirectory][build.bazel.remote.execution.v2.OutputDirectory]), as
	// well as files listed in `output_files`. Other files or directories that
	// may be created during command execution are discarded.
	//
	// The paths are relative to the working directory of the action execution.
	// The paths are specified using a single forward slash (`/`) as a path
	// separator, even if the execution platform natively uses a different
	// separator. The path MUST NOT include a trailing slash, nor a leading slash,
	// being a relative path. The special value of empty string is allowed,
	// although not recommended, and can be used to capture the entire working
	// directory tree, including inputs.
	//
	// In order to ensure consistent hashing of the same Action, the output paths
	// MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
	// bytes).
	//
	// An output directory cannot be duplicated or have the same path as any of
	// the listed output files. An output directory is allowed to be a parent of
	// another output directory.
	//
	// Directories leading up to the output directories (but not the output
	// directories themselves) are created by the worker prior to execution, even
	// if they are not explicitly part of the input root.
	//
	// DEPRECATED since 2.1: Use `output_paths` instead.
	OutputDirectories []string `protobuf:"bytes,4,rep,name=output_directories,json=outputDirectories,proto3" json:"output_directories,omitempty"`
	// A list of the output paths that the client expects to retrieve from the
	// action. Only the listed paths will be returned to the client as output.
	// The type of the output (file or directory) is not specified, and will be
	// determined by the server after action execution. If the resulting path is
	// a file, it will be returned in an
	// [OutputFile][build.bazel.remote.execution.v2.OutputFile]) typed field.
	// If the path is a directory, the entire directory structure will be returned
	// as a [Tree][build.bazel.remote.execution.v2.Tree] message digest, see
	// [OutputDirectory][build.bazel.remote.execution.v2.OutputDirectory])
	// Other files or directories that may be created during command execution
	// are discarded.
	//
	// The paths are relative to the working directory of the action execution.
	// The paths are specified using a single forward slash (`/`) as a path
	// separator, even if the execution platform natively uses a different
	// separator. The path MUST NOT include a trailing slash, nor a leading slash,
	// being a relative path.
	//
	// In order to ensure consistent hashing of the same Action, the output paths
	// MUST be deduplicated and sorted lexicographically by code point (or,
	// equivalently, by UTF-8 bytes).
	//
	// Directories leading up to the output paths are created by the worker prior
	// to execution, even if they are not explicitly part of the input root.
	//
	// New in v2.1: this field supersedes the DEPRECATED `output_files` and
	// `output_directories` fields. If `output_paths` is used, `output_files` and
	// `output_directories` will be ignored!
	OutputPaths []string `protobuf:"bytes,7,rep,name=output_paths,json=outputPaths,proto3" json:"output_paths,omitempty"`
	// The platform requirements for the execution environment. The server MAY
	// choose to execute the action on any worker satisfying the requirements, so
	// the client SHOULD ensure that running the action on any such worker will
	// have the same result.  A detailed lexicon for this can be found in the
	// accompanying platform.md.
	// DEPRECATED as of v2.2: platform properties are now specified directly in
	// the action. See documentation note in the
	// [Action][build.bazel.remote.execution.v2.Action] for migration.
	Platform *Platform `protobuf:"bytes,5,opt,name=platform,proto3" json:"platform,omitempty"`
	// The working directory, relative to the input root, for the command to run
	// in. It must be a directory which exists in the input tree. If it is left
	// empty, then the action is run in the input root.
	WorkingDirectory string `protobuf:"bytes,6,opt,name=working_directory,json=workingDirectory,proto3" json:"working_directory,omitempty"`
	// A list of keys for node properties the client expects to retrieve for
	// output files and directories. Keys are either names of string-based
	// [NodeProperty][build.bazel.remote.execution.v2.NodeProperty] or
	// names of fields in [NodeProperties][build.bazel.remote.execution.v2.NodeProperties].
	// In order to ensure that equivalent `Action`s always hash to the same
	// value, the node properties MUST be lexicographically sorted by name.
	// Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
	//
	// The interpretation of string-based properties is server-dependent. If a
	// property is not recognized by the server, the server will return an
	// `INVALID_ARGUMENT`.
	OutputNodeProperties []string `protobuf:"bytes,8,rep,name=output_node_properties,json=outputNodeProperties,proto3" json:"output_node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{1}
}

func (m *Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command.Unmarshal(m, b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command.Marshal(b, m, deterministic)
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return xxx_messageInfo_Command.Size(m)
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *Command) GetEnvironmentVariables() []*Command_EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}

func (m *Command) GetOutputFiles() []string {
	if m != nil {
		return m.OutputFiles
	}
	return nil
}

func (m *Command) GetOutputDirectories() []string {
	if m != nil {
		return m.OutputDirectories
	}
	return nil
}

func (m *Command) GetOutputPaths() []string {
	if m != nil {
		return m.OutputPaths
	}
	return nil
}

func (m *Command) GetPlatform() *Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

func (m *Command) GetWorkingDirectory() string {
	if m != nil {
		return m.WorkingDirectory
	}
	return ""
}

func (m *Command) GetOutputNodeProperties() []string {
	if m != nil {
		return m.OutputNodeProperties
	}
	return nil
}

// An `EnvironmentVariable` is one variable to set in the running program's
// environment.
type Command_EnvironmentVariable struct {
	// The variable name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The variable value.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_EnvironmentVariable) Reset()         { *m = Command_EnvironmentVariable{} }
func (m *Command_EnvironmentVariable) String() string { return proto.CompactTextString(m) }
func (*Command_EnvironmentVariable) ProtoMessage()    {}
func (*Command_EnvironmentVariable) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{1, 0}
}

func (m *Command_EnvironmentVariable) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_EnvironmentVariable.Unmarshal(m, b)
}
func (m *Command_EnvironmentVariable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_EnvironmentVariable.Marshal(b, m, deterministic)
}
func (m *Command_EnvironmentVariable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_EnvironmentVariable.Merge(m, src)
}
func (m *Command_EnvironmentVariable) XXX_Size() int {
	return xxx_messageInfo_Command_EnvironmentVariable.Size(m)
}
func (m *Command_EnvironmentVariable) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_EnvironmentVariable.DiscardUnknown(m)
}

var xxx_messageInfo_Command_EnvironmentVariable proto.InternalMessageInfo

func (m *Command_EnvironmentVariable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command_EnvironmentVariable) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A `Platform` is a set of requirements, such as hardware, operating system, or
// compiler toolchain, for an
// [Action][build.bazel.remote.execution.v2.Action]'s execution
// environment. A `Platform` is represented as a series of key-value pairs
// representing the properties that are required of the platform.
type Platform struct {
	// The properties that make up this platform. In order to ensure that
	// equivalent `Platform`s always hash to the same value, the properties MUST
	// be lexicographically sorted by name, and then by value. Sorting of strings
	// is done by code point, equivalently, by the UTF-8 bytes.
	Properties           []*Platform_Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Platform) Reset()         { *m = Platform{} }
func (m *Platform) String() string { return proto.CompactTextString(m) }
func (*Platform) ProtoMessage()    {}
func (*Platform) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{2}
}

func (m *Platform) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Platform.Unmarshal(m, b)
}
func (m *Platform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Platform.Marshal(b, m, deterministic)
}
func (m *Platform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Platform.Merge(m, src)
}
func (m *Platform) XXX_Size() int {
	return xxx_messageInfo_Platform.Size(m)
}
func (m *Platform) XXX_DiscardUnknown() {
	xxx_messageInfo_Platform.DiscardUnknown(m)
}

var xxx_messageInfo_Platform proto.InternalMessageInfo

func (m *Platform) GetProperties() []*Platform_Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

// A single property for the environment. The server is responsible for
// specifying the property `name`s that it accepts. If an unknown `name` is
// provided in the requirements for an
// [Action][build.bazel.remote.execution.v2.Action], the server SHOULD
// reject the execution request. If permitted by the server, the same `name`
// may occur multiple times.
//
// The server is also responsible for specifying the interpretation of
// property `value`s. For instance, a property describing how much RAM must be
// available may be interpreted as allowing a worker with 16GB to fulfill a
// request for 8GB, while a property describing the OS environment on which
// the action must be performed may require an exact match with the worker's
// OS.
//
// The server MAY use the `value` of one or more properties to determine how
// it sets up the execution environment, such as by making specific system
// files available to the worker.
//
// Both names and values are typically case-sensitive. Note that the platform
// is implicitly part of the action digest, so even tiny changes in the names
// or values (like changing case) may result in different action cache
// entries.
type Platform_Property struct {
	// The property name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The property value.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Platform_Property) Reset()         { *m = Platform_Property{} }
func (m *Platform_Property) String() string { return proto.CompactTextString(m) }
func (*Platform_Property) ProtoMessage()    {}
func (*Platform_Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{2, 0}
}

func (m *Platform_Property) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Platform_Property.Unmarshal(m, b)
}
func (m *Platform_Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Platform_Property.Marshal(b, m, deterministic)
}
func (m *Platform_Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Platform_Property.Merge(m, src)
}
func (m *Platform_Property) XXX_Size() int {
	return xxx_messageInfo_Platform_Property.Size(m)
}
func (m *Platform_Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Platform_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Platform_Property proto.InternalMessageInfo

func (m *Platform_Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Platform_Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A `Directory` represents a directory node in a file tree, containing zero or
// more children [FileNodes][build.bazel.remote.execution.v2.FileNode],
// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode] and
// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode].
// Each `Node` contains its name in the directory, either the digest of its
// content (either a file blob or a `Directory` proto) or a symlink target, as
// well as possibly some metadata about the file or directory.
//
// In order to ensure that two equivalent directory trees hash to the same
// value, the following restrictions MUST be obeyed when constructing a
// a `Directory`:
//
// * Every child in the directory must have a path of exactly one segment.
//   Multiple levels of directory hierarchy may not be collapsed.
// * Each child in the directory must have a unique path segment (file name).
//   Note that while the API itself is case-sensitive, the environment where
//   the Action is executed may or may not be case-sensitive. That is, it is
//   legal to call the API with a Directory that has both "Foo" and "foo" as
//   children, but the Action may be rejected by the remote system upon
//   execution.
// * The files, directories and symlinks in the directory must each be sorted
//   in lexicographical order by path. The path strings must be sorted by code
//   point, equivalently, by UTF-8 bytes.
// * The [NodeProperties][build.bazel.remote.execution.v2.NodeProperty] of files,
//   directories, and symlinks must be sorted in lexicographical order by
//   property name.
//
// A `Directory` that obeys the restrictions is said to be in canonical form.
//
// As an example, the following could be used for a file named `bar` and a
// directory named `foo` with an executable file named `baz` (hashes shortened
// for readability):
//
// ```json
// // (Directory proto)
// {
//   files: [
//     {
//       name: "bar",
//       digest: {
//         hash: "4a73bc9d03...",
//         size: 65534
//       },
//       node_properties: [
//         {
//           "name": "MTime",
//           "value": "2017-01-15T01:30:15.01Z"
//         }
//       ]
//     }
//   ],
//   directories: [
//     {
//       name: "foo",
//       digest: {
//         hash: "4cf2eda940...",
//         size: 43
//       }
//     }
//   ]
// }
//
// // (Directory proto with hash "4cf2eda940..." and size 43)
// {
//   files: [
//     {
//       name: "baz",
//       digest: {
//         hash: "b2c941073e...",
//         size: 1294,
//       },
//       is_executable: true
//     }
//   ]
// }
// ```
type Directory struct {
	// The files in the directory.
	Files []*FileNode `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	// The subdirectories in the directory.
	Directories []*DirectoryNode `protobuf:"bytes,2,rep,name=directories,proto3" json:"directories,omitempty"`
	// The symlinks in the directory.
	Symlinks             []*SymlinkNode  `protobuf:"bytes,3,rep,name=symlinks,proto3" json:"symlinks,omitempty"`
	NodeProperties       *NodeProperties `protobuf:"bytes,5,opt,name=node_properties,json=nodeProperties,proto3" json:"node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Directory) Reset()         { *m = Directory{} }
func (m *Directory) String() string { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()    {}
func (*Directory) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{3}
}

func (m *Directory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Directory.Unmarshal(m, b)
}
func (m *Directory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Directory.Marshal(b, m, deterministic)
}
func (m *Directory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Directory.Merge(m, src)
}
func (m *Directory) XXX_Size() int {
	return xxx_messageInfo_Directory.Size(m)
}
func (m *Directory) XXX_DiscardUnknown() {
	xxx_messageInfo_Directory.DiscardUnknown(m)
}

var xxx_messageInfo_Directory proto.InternalMessageInfo

func (m *Directory) GetFiles() []*FileNode {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *Directory) GetDirectories() []*DirectoryNode {
	if m != nil {
		return m.Directories
	}
	return nil
}

func (m *Directory) GetSymlinks() []*SymlinkNode {
	if m != nil {
		return m.Symlinks
	}
	return nil
}

func (m *Directory) GetNodeProperties() *NodeProperties {
	if m != nil {
		return m.NodeProperties
	}
	return nil
}

// A single property for [FileNodes][build.bazel.remote.execution.v2.FileNode],
// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode], and
// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode]. The server is
// responsible for specifying the property `name`s that it accepts. If
// permitted by the server, the same `name` may occur multiple times.
type NodeProperty struct {
	// The property name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The property value.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeProperty) Reset()         { *m = NodeProperty{} }
func (m *NodeProperty) String() string { return proto.CompactTextString(m) }
func (*NodeProperty) ProtoMessage()    {}
func (*NodeProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{4}
}

func (m *NodeProperty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeProperty.Unmarshal(m, b)
}
func (m *NodeProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeProperty.Marshal(b, m, deterministic)
}
func (m *NodeProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProperty.Merge(m, src)
}
func (m *NodeProperty) XXX_Size() int {
	return xxx_messageInfo_NodeProperty.Size(m)
}
func (m *NodeProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProperty.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProperty proto.InternalMessageInfo

func (m *NodeProperty) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeProperty) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Node properties for [FileNodes][build.bazel.remote.execution.v2.FileNode],
// [DirectoryNodes][build.bazel.remote.execution.v2.DirectoryNode], and
// [SymlinkNodes][build.bazel.remote.execution.v2.SymlinkNode]. The server is
// responsible for specifying the properties that it accepts.
//
type NodeProperties struct {
	// A list of string-based
	// [NodeProperties][build.bazel.remote.execution.v2.NodeProperty].
	Properties []*NodeProperty `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	// The file's last modification timestamp.
	Mtime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// The UNIX file mode, e.g., 0755.
	UnixMode             *wrappers.UInt32Value `protobuf:"bytes,3,opt,name=unix_mode,json=unixMode,proto3" json:"unix_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *NodeProperties) Reset()         { *m = NodeProperties{} }
func (m *NodeProperties) String() string { return proto.CompactTextString(m) }
func (*NodeProperties) ProtoMessage()    {}
func (*NodeProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{5}
}

func (m *NodeProperties) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeProperties.Unmarshal(m, b)
}
func (m *NodeProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeProperties.Marshal(b, m, deterministic)
}
func (m *NodeProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProperties.Merge(m, src)
}
func (m *NodeProperties) XXX_Size() int {
	return xxx_messageInfo_NodeProperties.Size(m)
}
func (m *NodeProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProperties.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProperties proto.InternalMessageInfo

func (m *NodeProperties) GetProperties() []*NodeProperty {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *NodeProperties) GetMtime() *timestamp.Timestamp {
	if m != nil {
		return m.Mtime
	}
	return nil
}

func (m *NodeProperties) GetUnixMode() *wrappers.UInt32Value {
	if m != nil {
		return m.UnixMode
	}
	return nil
}

// A `FileNode` represents a single file and associated metadata.
type FileNode struct {
	// The name of the file.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The digest of the file's content.
	Digest *Digest `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	// True if file is executable, false otherwise.
	IsExecutable         bool            `protobuf:"varint,4,opt,name=is_executable,json=isExecutable,proto3" json:"is_executable,omitempty"`
	NodeProperties       *NodeProperties `protobuf:"bytes,6,opt,name=node_properties,json=nodeProperties,proto3" json:"node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FileNode) Reset()         { *m = FileNode{} }
func (m *FileNode) String() string { return proto.CompactTextString(m) }
func (*FileNode) ProtoMessage()    {}
func (*FileNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{6}
}

func (m *FileNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileNode.Unmarshal(m, b)
}
func (m *FileNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileNode.Marshal(b, m, deterministic)
}
func (m *FileNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileNode.Merge(m, src)
}
func (m *FileNode) XXX_Size() int {
	return xxx_messageInfo_FileNode.Size(m)
}
func (m *FileNode) XXX_DiscardUnknown() {
	xxx_messageInfo_FileNode.DiscardUnknown(m)
}

var xxx_messageInfo_FileNode proto.InternalMessageInfo

func (m *FileNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileNode) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *FileNode) GetIsExecutable() bool {
	if m != nil {
		return m.IsExecutable
	}
	return false
}

func (m *FileNode) GetNodeProperties() *NodeProperties {
	if m != nil {
		return m.NodeProperties
	}
	return nil
}

// A `DirectoryNode` represents a child of a
// [Directory][build.bazel.remote.execution.v2.Directory] which is itself
// a `Directory` and its associated metadata.
type DirectoryNode struct {
	// The name of the directory.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The digest of the
	// [Directory][build.bazel.remote.execution.v2.Directory] object
	// represented. See [Digest][build.bazel.remote.execution.v2.Digest]
	// for information about how to take the digest of a proto message.
	Digest               *Digest  `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DirectoryNode) Reset()         { *m = DirectoryNode{} }
func (m *DirectoryNode) String() string { return proto.CompactTextString(m) }
func (*DirectoryNode) ProtoMessage()    {}
func (*DirectoryNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{7}
}

func (m *DirectoryNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DirectoryNode.Unmarshal(m, b)
}
func (m *DirectoryNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DirectoryNode.Marshal(b, m, deterministic)
}
func (m *DirectoryNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectoryNode.Merge(m, src)
}
func (m *DirectoryNode) XXX_Size() int {
	return xxx_messageInfo_DirectoryNode.Size(m)
}
func (m *DirectoryNode) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectoryNode.DiscardUnknown(m)
}

var xxx_messageInfo_DirectoryNode proto.InternalMessageInfo

func (m *DirectoryNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DirectoryNode) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

// A `SymlinkNode` represents a symbolic link.
type SymlinkNode struct {
	// The name of the symlink.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The target path of the symlink. The path separator is a forward slash `/`.
	// The target path can be relative to the parent directory of the symlink or
	// it can be an absolute path starting with `/`. Support for absolute paths
	// can be checked using the [Capabilities][build.bazel.remote.execution.v2.Capabilities]
	// API. `..` components are allowed anywhere in the target path as logical
	// canonicalization may lead to different behavior in the presence of
	// directory symlinks (e.g. `foo/../bar` may not be the same as `bar`).
	// To reduce potential cache misses, canonicalization is still recommended
	// where this is possible without impacting correctness.
	Target               string          `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	NodeProperties       *NodeProperties `protobuf:"bytes,4,opt,name=node_properties,json=nodeProperties,proto3" json:"node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SymlinkNode) Reset()         { *m = SymlinkNode{} }
func (m *SymlinkNode) String() string { return proto.CompactTextString(m) }
func (*SymlinkNode) ProtoMessage()    {}
func (*SymlinkNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{8}
}

func (m *SymlinkNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SymlinkNode.Unmarshal(m, b)
}
func (m *SymlinkNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SymlinkNode.Marshal(b, m, deterministic)
}
func (m *SymlinkNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymlinkNode.Merge(m, src)
}
func (m *SymlinkNode) XXX_Size() int {
	return xxx_messageInfo_SymlinkNode.Size(m)
}
func (m *SymlinkNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SymlinkNode.DiscardUnknown(m)
}

var xxx_messageInfo_SymlinkNode proto.InternalMessageInfo

func (m *SymlinkNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SymlinkNode) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *SymlinkNode) GetNodeProperties() *NodeProperties {
	if m != nil {
		return m.NodeProperties
	}
	return nil
}

// A content digest. A digest for a given blob consists of the size of the blob
// and its hash. The hash algorithm to use is defined by the server.
//
// The size is considered to be an integral part of the digest and cannot be
// separated. That is, even if the `hash` field is correctly specified but
// `size_bytes` is not, the server MUST reject the request.
//
// The reason for including the size in the digest is as follows: in a great
// many cases, the server needs to know the size of the blob it is about to work
// with prior to starting an operation with it, such as flattening Merkle tree
// structures or streaming it to a worker. Technically, the server could
// implement a separate metadata store, but this results in a significantly more
// complicated implementation as opposed to having the client specify the size
// up-front (or storing the size along with the digest in every message where
// digests are embedded). This does mean that the API leaks some implementation
// details of (what we consider to be) a reasonable server implementation, but
// we consider this to be a worthwhile tradeoff.
//
// When a `Digest` is used to refer to a proto message, it always refers to the
// message in binary encoded form. To ensure consistent hashing, clients and
// servers MUST ensure that they serialize messages according to the following
// rules, even if there are alternate valid encodings for the same message:
//
// * Fields are serialized in tag order.
// * There are no unknown fields.
// * There are no duplicate fields.
// * Fields are serialized according to the default semantics for their type.
//
// Most protocol buffer implementations will always follow these rules when
// serializing, but care should be taken to avoid shortcuts. For instance,
// concatenating two messages to merge them may produce duplicate fields.
type Digest struct {
	// The hash. In the case of SHA-256, it will always be a lowercase hex string
	// exactly 64 characters long.
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// The size of the blob, in bytes.
	SizeBytes            int64    `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Digest) Reset()         { *m = Digest{} }
func (m *Digest) String() string { return proto.CompactTextString(m) }
func (*Digest) ProtoMessage()    {}
func (*Digest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{9}
}

func (m *Digest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Digest.Unmarshal(m, b)
}
func (m *Digest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Digest.Marshal(b, m, deterministic)
}
func (m *Digest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Digest.Merge(m, src)
}
func (m *Digest) XXX_Size() int {
	return xxx_messageInfo_Digest.Size(m)
}
func (m *Digest) XXX_DiscardUnknown() {
	xxx_messageInfo_Digest.DiscardUnknown(m)
}

var xxx_messageInfo_Digest proto.InternalMessageInfo

func (m *Digest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Digest) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// ExecutedActionMetadata contains details about a completed execution.
type ExecutedActionMetadata struct {
	// The name of the worker which ran the execution.
	Worker string `protobuf:"bytes,1,opt,name=worker,proto3" json:"worker,omitempty"`
	// When was the action added to the queue.
	QueuedTimestamp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=queued_timestamp,json=queuedTimestamp,proto3" json:"queued_timestamp,omitempty"`
	// When the worker received the action.
	WorkerStartTimestamp *timestamp.Timestamp `protobuf:"bytes,3,opt,name=worker_start_timestamp,json=workerStartTimestamp,proto3" json:"worker_start_timestamp,omitempty"`
	// When the worker completed the action, including all stages.
	WorkerCompletedTimestamp *timestamp.Timestamp `protobuf:"bytes,4,opt,name=worker_completed_timestamp,json=workerCompletedTimestamp,proto3" json:"worker_completed_timestamp,omitempty"`
	// When the worker started fetching action inputs.
	InputFetchStartTimestamp *timestamp.Timestamp `protobuf:"bytes,5,opt,name=input_fetch_start_timestamp,json=inputFetchStartTimestamp,proto3" json:"input_fetch_start_timestamp,omitempty"`
	// When the worker finished fetching action inputs.
	InputFetchCompletedTimestamp *timestamp.Timestamp `protobuf:"bytes,6,opt,name=input_fetch_completed_timestamp,json=inputFetchCompletedTimestamp,proto3" json:"input_fetch_completed_timestamp,omitempty"`
	// When the worker started executing the action command.
	ExecutionStartTimestamp *timestamp.Timestamp `protobuf:"bytes,7,opt,name=execution_start_timestamp,json=executionStartTimestamp,proto3" json:"execution_start_timestamp,omitempty"`
	// When the worker completed executing the action command.
	ExecutionCompletedTimestamp *timestamp.Timestamp `protobuf:"bytes,8,opt,name=execution_completed_timestamp,json=executionCompletedTimestamp,proto3" json:"execution_completed_timestamp,omitempty"`
	// When the worker started uploading action outputs.
	OutputUploadStartTimestamp *timestamp.Timestamp `protobuf:"bytes,9,opt,name=output_upload_start_timestamp,json=outputUploadStartTimestamp,proto3" json:"output_upload_start_timestamp,omitempty"`
	// When the worker finished uploading action outputs.
	OutputUploadCompletedTimestamp *timestamp.Timestamp `protobuf:"bytes,10,opt,name=output_upload_completed_timestamp,json=outputUploadCompletedTimestamp,proto3" json:"output_upload_completed_timestamp,omitempty"`
	// Details that are specific to the kind of worker used. For example,
	// on POSIX-like systems this could contain a message with
	// getrusage(2) statistics.
	AuxiliaryMetadata    []*any.Any `protobuf:"bytes,11,rep,name=auxiliary_metadata,json=auxiliaryMetadata,proto3" json:"auxiliary_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ExecutedActionMetadata) Reset()         { *m = ExecutedActionMetadata{} }
func (m *ExecutedActionMetadata) String() string { return proto.CompactTextString(m) }
func (*ExecutedActionMetadata) ProtoMessage()    {}
func (*ExecutedActionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{10}
}

func (m *ExecutedActionMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecutedActionMetadata.Unmarshal(m, b)
}
func (m *ExecutedActionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecutedActionMetadata.Marshal(b, m, deterministic)
}
func (m *ExecutedActionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutedActionMetadata.Merge(m, src)
}
func (m *ExecutedActionMetadata) XXX_Size() int {
	return xxx_messageInfo_ExecutedActionMetadata.Size(m)
}
func (m *ExecutedActionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutedActionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutedActionMetadata proto.InternalMessageInfo

func (m *ExecutedActionMetadata) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

func (m *ExecutedActionMetadata) GetQueuedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.QueuedTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetWorkerStartTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.WorkerStartTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetWorkerCompletedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.WorkerCompletedTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetInputFetchStartTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.InputFetchStartTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetInputFetchCompletedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.InputFetchCompletedTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetExecutionStartTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.ExecutionStartTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetExecutionCompletedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.ExecutionCompletedTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetOutputUploadStartTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.OutputUploadStartTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetOutputUploadCompletedTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.OutputUploadCompletedTimestamp
	}
	return nil
}

func (m *ExecutedActionMetadata) GetAuxiliaryMetadata() []*any.Any {
	if m != nil {
		return m.AuxiliaryMetadata
	}
	return nil
}

// An ActionResult represents the result of an
// [Action][build.bazel.remote.execution.v2.Action] being run.
//
// It is advised that at least one field (for example
// `ActionResult.execution_metadata.Worker`) have a non-default value, to
// ensure that the serialized value is non-empty, which can then be used
// as a basic data sanity check.
type ActionResult struct {
	// The output files of the action. For each output file requested in the
	// `output_files` or `output_paths` field of the Action, if the corresponding
	// file existed after the action completed, a single entry will be present
	// either in this field, or the `output_file_symlinks` field if the file was
	// a symbolic link to another file (`output_symlinks` field after v2.1).
	//
	// If an output listed in `output_files` was found, but was a directory rather
	// than a regular file, the server will return a FAILED_PRECONDITION.
	// If the action does not produce the requested output, then that output
	// will be omitted from the list. The server is free to arrange the output
	// list as desired; clients MUST NOT assume that the output list is sorted.
	OutputFiles []*OutputFile `protobuf:"bytes,2,rep,name=output_files,json=outputFiles,proto3" json:"output_files,omitempty"`
	// The output files of the action that are symbolic links to other files. Those
	// may be links to other output files, or input files, or even absolute paths
	// outside of the working directory, if the server supports
	// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
	// For each output file requested in the `output_files` or `output_paths`
	// field of the Action, if the corresponding file existed after
	// the action completed, a single entry will be present either in this field,
	// or in the `output_files` field, if the file was not a symbolic link.
	//
	// If an output symbolic link of the same name as listed in `output_files` of
	// the Command was found, but its target type was not a regular file, the
	// server will return a FAILED_PRECONDITION.
	// If the action does not produce the requested output, then that output
	// will be omitted from the list. The server is free to arrange the output
	// list as desired; clients MUST NOT assume that the output list is sorted.
	//
	// DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API
	// should still populate this field in addition to `output_symlinks`.
	OutputFileSymlinks []*OutputSymlink `protobuf:"bytes,10,rep,name=output_file_symlinks,json=outputFileSymlinks,proto3" json:"output_file_symlinks,omitempty"`
	// New in v2.1: this field will only be populated if the command
	// `output_paths` field was used, and not the pre v2.1 `output_files` or
	// `output_directories` fields.
	// The output paths of the action that are symbolic links to other paths. Those
	// may be links to other outputs, or inputs, or even absolute paths
	// outside of the working directory, if the server supports
	// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
	// A single entry for each output requested in `output_paths`
	// field of the Action, if the corresponding path existed after
	// the action completed and was a symbolic link.
	//
	// If the action does not produce a requested output, then that output
	// will be omitted from the list. The server is free to arrange the output
	// list as desired; clients MUST NOT assume that the output list is sorted.
	OutputSymlinks []*OutputSymlink `protobuf:"bytes,12,rep,name=output_symlinks,json=outputSymlinks,proto3" json:"output_symlinks,omitempty"`
	// The output directories of the action. For each output directory requested
	// in the `output_directories` or `output_paths` field of the Action, if the
	// corresponding directory existed after the action completed, a single entry
	// will be present in the output list, which will contain the digest of a
	// [Tree][build.bazel.remote.execution.v2.Tree] message containing the
	// directory tree, and the path equal exactly to the corresponding Action
	// output_directories member.
	//
	// As an example, suppose the Action had an output directory `a/b/dir` and the
	// execution produced the following contents in `a/b/dir`: a file named `bar`
	// and a directory named `foo` with an executable file named `baz`. Then,
	// output_directory will contain (hashes shortened for readability):
	//
	// ```json
	// // OutputDirectory proto:
	// {
	//   path: "a/b/dir"
	//   tree_digest: {
	//     hash: "4a73bc9d03...",
	//     size: 55
	//   }
	// }
	// // Tree proto with hash "4a73bc9d03..." and size 55:
	// {
	//   root: {
	//     files: [
	//       {
	//         name: "bar",
	//         digest: {
	//           hash: "4a73bc9d03...",
	//           size: 65534
	//         }
	//       }
	//     ],
	//     directories: [
	//       {
	//         name: "foo",
	//         digest: {
	//           hash: "4cf2eda940...",
	//           size: 43
	//         }
	//       }
	//     ]
	//   }
	//   children : {
	//     // (Directory proto with hash "4cf2eda940..." and size 43)
	//     files: [
	//       {
	//         name: "baz",
	//         digest: {
	//           hash: "b2c941073e...",
	//           size: 1294,
	//         },
	//         is_executable: true
	//       }
	//     ]
	//   }
	// }
	// ```
	// If an output of the same name as listed in `output_files` of
	// the Command was found in `output_directories`, but was not a directory, the
	// server will return a FAILED_PRECONDITION.
	OutputDirectories []*OutputDirectory `protobuf:"bytes,3,rep,name=output_directories,json=outputDirectories,proto3" json:"output_directories,omitempty"`
	// The output directories of the action that are symbolic links to other
	// directories. Those may be links to other output directories, or input
	// directories, or even absolute paths outside of the working directory,
	// if the server supports
	// [SymlinkAbsolutePathStrategy.ALLOWED][build.bazel.remote.execution.v2.CacheCapabilities.SymlinkAbsolutePathStrategy].
	// For each output directory requested in the `output_directories` field of
	// the Action, if the directory existed after the action completed, a
	// single entry will be present either in this field, or in the
	// `output_directories` field, if the directory was not a symbolic link.
	//
	// If an output of the same name was found, but was a symbolic link to a file
	// instead of a directory, the server will return a FAILED_PRECONDITION.
	// If the action does not produce the requested output, then that output
	// will be omitted from the list. The server is free to arrange the output
	// list as desired; clients MUST NOT assume that the output list is sorted.
	//
	// DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API
	// should still populate this field in addition to `output_symlinks`.
	OutputDirectorySymlinks []*OutputSymlink `protobuf:"bytes,11,rep,name=output_directory_symlinks,json=outputDirectorySymlinks,proto3" json:"output_directory_symlinks,omitempty"`
	// The exit code of the command.
	ExitCode int32 `protobuf:"varint,4,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// The standard output buffer of the action. The server SHOULD NOT inline
	// stdout unless requested by the client in the
	// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
	// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
	// would cause the response to exceed message size limits.
	StdoutRaw []byte `protobuf:"bytes,5,opt,name=stdout_raw,json=stdoutRaw,proto3" json:"stdout_raw,omitempty"`
	// The digest for a blob containing the standard output of the action, which
	// can be retrieved from the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	StdoutDigest *Digest `protobuf:"bytes,6,opt,name=stdout_digest,json=stdoutDigest,proto3" json:"stdout_digest,omitempty"`
	// The standard error buffer of the action. The server SHOULD NOT inline
	// stderr unless requested by the client in the
	// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
	// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
	// would cause the response to exceed message size limits.
	StderrRaw []byte `protobuf:"bytes,7,opt,name=stderr_raw,json=stderrRaw,proto3" json:"stderr_raw,omitempty"`
	// The digest for a blob containing the standard error of the action, which
	// can be retrieved from the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	StderrDigest *Digest `protobuf:"bytes,8,opt,name=stderr_digest,json=stderrDigest,proto3" json:"stderr_digest,omitempty"`
	// The details of the execution that originally produced this result.
	ExecutionMetadata    *ExecutedActionMetadata `protobuf:"bytes,9,opt,name=execution_metadata,json=executionMetadata,proto3" json:"execution_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ActionResult) Reset()         { *m = ActionResult{} }
func (m *ActionResult) String() string { return proto.CompactTextString(m) }
func (*ActionResult) ProtoMessage()    {}
func (*ActionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{11}
}

func (m *ActionResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ActionResult.Unmarshal(m, b)
}
func (m *ActionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ActionResult.Marshal(b, m, deterministic)
}
func (m *ActionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionResult.Merge(m, src)
}
func (m *ActionResult) XXX_Size() int {
	return xxx_messageInfo_ActionResult.Size(m)
}
func (m *ActionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ActionResult proto.InternalMessageInfo

func (m *ActionResult) GetOutputFiles() []*OutputFile {
	if m != nil {
		return m.OutputFiles
	}
	return nil
}

func (m *ActionResult) GetOutputFileSymlinks() []*OutputSymlink {
	if m != nil {
		return m.OutputFileSymlinks
	}
	return nil
}

func (m *ActionResult) GetOutputSymlinks() []*OutputSymlink {
	if m != nil {
		return m.OutputSymlinks
	}
	return nil
}

func (m *ActionResult) GetOutputDirectories() []*OutputDirectory {
	if m != nil {
		return m.OutputDirectories
	}
	return nil
}

func (m *ActionResult) GetOutputDirectorySymlinks() []*OutputSymlink {
	if m != nil {
		return m.OutputDirectorySymlinks
	}
	return nil
}

func (m *ActionResult) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ActionResult) GetStdoutRaw() []byte {
	if m != nil {
		return m.StdoutRaw
	}
	return nil
}

func (m *ActionResult) GetStdoutDigest() *Digest {
	if m != nil {
		return m.StdoutDigest
	}
	return nil
}

func (m *ActionResult) GetStderrRaw() []byte {
	if m != nil {
		return m.StderrRaw
	}
	return nil
}

func (m *ActionResult) GetStderrDigest() *Digest {
	if m != nil {
		return m.StderrDigest
	}
	return nil
}

func (m *ActionResult) GetExecutionMetadata() *ExecutedActionMetadata {
	if m != nil {
		return m.ExecutionMetadata
	}
	return nil
}

// An `OutputFile` is similar to a
// [FileNode][build.bazel.remote.execution.v2.FileNode], but it is used as an
// output in an `ActionResult`. It allows a full file path rather than
// only a name.
type OutputFile struct {
	// The full path of the file relative to the working directory, including the
	// filename. The path separator is a forward slash `/`. Since this is a
	// relative path, it MUST NOT begin with a leading forward slash.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The digest of the file's content.
	Digest *Digest `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	// True if file is executable, false otherwise.
	IsExecutable bool `protobuf:"varint,4,opt,name=is_executable,json=isExecutable,proto3" json:"is_executable,omitempty"`
	// The contents of the file if inlining was requested. The server SHOULD NOT inline
	// file contents unless requested by the client in the
	// [GetActionResultRequest][build.bazel.remote.execution.v2.GetActionResultRequest]
	// message. The server MAY omit inlining, even if requested, and MUST do so if inlining
	// would cause the response to exceed message size limits.
	Contents             []byte          `protobuf:"bytes,5,opt,name=contents,proto3" json:"contents,omitempty"`
	NodeProperties       *NodeProperties `protobuf:"bytes,7,opt,name=node_properties,json=nodeProperties,proto3" json:"node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OutputFile) Reset()         { *m = OutputFile{} }
func (m *OutputFile) String() string { return proto.CompactTextString(m) }
func (*OutputFile) ProtoMessage()    {}
func (*OutputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{12}
}

func (m *OutputFile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputFile.Unmarshal(m, b)
}
func (m *OutputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputFile.Marshal(b, m, deterministic)
}
func (m *OutputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputFile.Merge(m, src)
}
func (m *OutputFile) XXX_Size() int {
	return xxx_messageInfo_OutputFile.Size(m)
}
func (m *OutputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputFile.DiscardUnknown(m)
}

var xxx_messageInfo_OutputFile proto.InternalMessageInfo

func (m *OutputFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OutputFile) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *OutputFile) GetIsExecutable() bool {
	if m != nil {
		return m.IsExecutable
	}
	return false
}

func (m *OutputFile) GetContents() []byte {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *OutputFile) GetNodeProperties() *NodeProperties {
	if m != nil {
		return m.NodeProperties
	}
	return nil
}

// A `Tree` contains all the
// [Directory][build.bazel.remote.execution.v2.Directory] protos in a
// single directory Merkle tree, compressed into one message.
type Tree struct {
	// The root directory in the tree.
	Root *Directory `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// All the child directories: the directories referred to by the root and,
	// recursively, all its children. In order to reconstruct the directory tree,
	// the client must take the digests of each of the child directories and then
	// build up a tree starting from the `root`.
	Children             []*Directory `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}
func (*Tree) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{13}
}

func (m *Tree) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tree.Unmarshal(m, b)
}
func (m *Tree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tree.Marshal(b, m, deterministic)
}
func (m *Tree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tree.Merge(m, src)
}
func (m *Tree) XXX_Size() int {
	return xxx_messageInfo_Tree.Size(m)
}
func (m *Tree) XXX_DiscardUnknown() {
	xxx_messageInfo_Tree.DiscardUnknown(m)
}

var xxx_messageInfo_Tree proto.InternalMessageInfo

func (m *Tree) GetRoot() *Directory {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Tree) GetChildren() []*Directory {
	if m != nil {
		return m.Children
	}
	return nil
}

// An `OutputDirectory` is the output in an `ActionResult` corresponding to a
// directory's full contents rather than a single file.
type OutputDirectory struct {
	// The full path of the directory relative to the working directory. The path
	// separator is a forward slash `/`. Since this is a relative path, it MUST
	// NOT begin with a leading forward slash. The empty string value is allowed,
	// and it denotes the entire working directory.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The digest of the encoded
	// [Tree][build.bazel.remote.execution.v2.Tree] proto containing the
	// directory's contents.
	TreeDigest           *Digest  `protobuf:"bytes,3,opt,name=tree_digest,json=treeDigest,proto3" json:"tree_digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutputDirectory) Reset()         { *m = OutputDirectory{} }
func (m *OutputDirectory) String() string { return proto.CompactTextString(m) }
func (*OutputDirectory) ProtoMessage()    {}
func (*OutputDirectory) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{14}
}

func (m *OutputDirectory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputDirectory.Unmarshal(m, b)
}
func (m *OutputDirectory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputDirectory.Marshal(b, m, deterministic)
}
func (m *OutputDirectory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputDirectory.Merge(m, src)
}
func (m *OutputDirectory) XXX_Size() int {
	return xxx_messageInfo_OutputDirectory.Size(m)
}
func (m *OutputDirectory) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputDirectory.DiscardUnknown(m)
}

var xxx_messageInfo_OutputDirectory proto.InternalMessageInfo

func (m *OutputDirectory) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OutputDirectory) GetTreeDigest() *Digest {
	if m != nil {
		return m.TreeDigest
	}
	return nil
}

// An `OutputSymlink` is similar to a
// [Symlink][build.bazel.remote.execution.v2.SymlinkNode], but it is used as an
// output in an `ActionResult`.
//
// `OutputSymlink` is binary-compatible with `SymlinkNode`.
type OutputSymlink struct {
	// The full path of the symlink relative to the working directory, including the
	// filename. The path separator is a forward slash `/`. Since this is a
	// relative path, it MUST NOT begin with a leading forward slash.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The target path of the symlink. The path separator is a forward slash `/`.
	// The target path can be relative to the parent directory of the symlink or
	// it can be an absolute path starting with `/`. Support for absolute paths
	// can be checked using the [Capabilities][build.bazel.remote.execution.v2.Capabilities]
	// API. `..` components are allowed anywhere in the target path.
	Target               string          `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	NodeProperties       *NodeProperties `protobuf:"bytes,4,opt,name=node_properties,json=nodeProperties,proto3" json:"node_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OutputSymlink) Reset()         { *m = OutputSymlink{} }
func (m *OutputSymlink) String() string { return proto.CompactTextString(m) }
func (*OutputSymlink) ProtoMessage()    {}
func (*OutputSymlink) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{15}
}

func (m *OutputSymlink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputSymlink.Unmarshal(m, b)
}
func (m *OutputSymlink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputSymlink.Marshal(b, m, deterministic)
}
func (m *OutputSymlink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputSymlink.Merge(m, src)
}
func (m *OutputSymlink) XXX_Size() int {
	return xxx_messageInfo_OutputSymlink.Size(m)
}
func (m *OutputSymlink) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputSymlink.DiscardUnknown(m)
}

var xxx_messageInfo_OutputSymlink proto.InternalMessageInfo

func (m *OutputSymlink) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OutputSymlink) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *OutputSymlink) GetNodeProperties() *NodeProperties {
	if m != nil {
		return m.NodeProperties
	}
	return nil
}

// An `ExecutionPolicy` can be used to control the scheduling of the action.
type ExecutionPolicy struct {
	// The priority (relative importance) of this action. Generally, a lower value
	// means that the action should be run sooner than actions having a greater
	// priority value, but the interpretation of a given value is server-
	// dependent. A priority of 0 means the *default* priority. Priorities may be
	// positive or negative, and such actions should run later or sooner than
	// actions having the default priority, respectively. The particular semantics
	// of this field is up to the server. In particular, every server will have
	// their own supported range of priorities, and will decide how these map into
	// scheduling policy.
	Priority             int32    `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecutionPolicy) Reset()         { *m = ExecutionPolicy{} }
func (m *ExecutionPolicy) String() string { return proto.CompactTextString(m) }
func (*ExecutionPolicy) ProtoMessage()    {}
func (*ExecutionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{16}
}

func (m *ExecutionPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecutionPolicy.Unmarshal(m, b)
}
func (m *ExecutionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecutionPolicy.Marshal(b, m, deterministic)
}
func (m *ExecutionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionPolicy.Merge(m, src)
}
func (m *ExecutionPolicy) XXX_Size() int {
	return xxx_messageInfo_ExecutionPolicy.Size(m)
}
func (m *ExecutionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionPolicy proto.InternalMessageInfo

func (m *ExecutionPolicy) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// A `ResultsCachePolicy` is used for fine-grained control over how action
// outputs are stored in the CAS and Action Cache.
type ResultsCachePolicy struct {
	// The priority (relative importance) of this content in the overall cache.
	// Generally, a lower value means a longer retention time or other advantage,
	// but the interpretation of a given value is server-dependent. A priority of
	// 0 means a *default* value, decided by the server.
	//
	// The particular semantics of this field is up to the server. In particular,
	// every server will have their own supported range of priorities, and will
	// decide how these map into retention/eviction policy.
	Priority             int32    `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultsCachePolicy) Reset()         { *m = ResultsCachePolicy{} }
func (m *ResultsCachePolicy) String() string { return proto.CompactTextString(m) }
func (*ResultsCachePolicy) ProtoMessage()    {}
func (*ResultsCachePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{17}
}

func (m *ResultsCachePolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResultsCachePolicy.Unmarshal(m, b)
}
func (m *ResultsCachePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResultsCachePolicy.Marshal(b, m, deterministic)
}
func (m *ResultsCachePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultsCachePolicy.Merge(m, src)
}
func (m *ResultsCachePolicy) XXX_Size() int {
	return xxx_messageInfo_ResultsCachePolicy.Size(m)
}
func (m *ResultsCachePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultsCachePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ResultsCachePolicy proto.InternalMessageInfo

func (m *ResultsCachePolicy) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// A request message for
// [Execution.Execute][build.bazel.remote.execution.v2.Execution.Execute].
type ExecuteRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// If true, the action will be executed even if its result is already
	// present in the [ActionCache][build.bazel.remote.execution.v2.ActionCache].
	// The execution is still allowed to be merged with other in-flight executions
	// of the same action, however - semantically, the service MUST only guarantee
	// that the results of an execution with this field set were not visible
	// before the corresponding execution request was sent.
	// Note that actions from execution requests setting this field set are still
	// eligible to be entered into the action cache upon completion, and services
	// SHOULD overwrite any existing entries that may exist. This allows
	// skip_cache_lookup requests to be used as a mechanism for replacing action
	// cache entries that reference outputs no longer available or that are
	// poisoned in any way.
	// If false, the result may be served from the action cache.
	SkipCacheLookup bool `protobuf:"varint,3,opt,name=skip_cache_lookup,json=skipCacheLookup,proto3" json:"skip_cache_lookup,omitempty"`
	// The digest of the [Action][build.bazel.remote.execution.v2.Action] to
	// execute.
	ActionDigest *Digest `protobuf:"bytes,6,opt,name=action_digest,json=actionDigest,proto3" json:"action_digest,omitempty"`
	// An optional policy for execution of the action.
	// The server will have a default policy if this is not provided.
	ExecutionPolicy *ExecutionPolicy `protobuf:"bytes,7,opt,name=execution_policy,json=executionPolicy,proto3" json:"execution_policy,omitempty"`
	// An optional policy for the results of this execution in the remote cache.
	// The server will have a default policy if this is not provided.
	// This may be applied to both the ActionResult and the associated blobs.
	ResultsCachePolicy   *ResultsCachePolicy `protobuf:"bytes,8,opt,name=results_cache_policy,json=resultsCachePolicy,proto3" json:"results_cache_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ExecuteRequest) Reset()         { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()    {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{18}
}

func (m *ExecuteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteRequest.Unmarshal(m, b)
}
func (m *ExecuteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteRequest.Marshal(b, m, deterministic)
}
func (m *ExecuteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteRequest.Merge(m, src)
}
func (m *ExecuteRequest) XXX_Size() int {
	return xxx_messageInfo_ExecuteRequest.Size(m)
}
func (m *ExecuteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteRequest proto.InternalMessageInfo

func (m *ExecuteRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *ExecuteRequest) GetSkipCacheLookup() bool {
	if m != nil {
		return m.SkipCacheLookup
	}
	return false
}

func (m *ExecuteRequest) GetActionDigest() *Digest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

func (m *ExecuteRequest) GetExecutionPolicy() *ExecutionPolicy {
	if m != nil {
		return m.ExecutionPolicy
	}
	return nil
}

func (m *ExecuteRequest) GetResultsCachePolicy() *ResultsCachePolicy {
	if m != nil {
		return m.ResultsCachePolicy
	}
	return nil
}

// A `LogFile` is a log stored in the CAS.
type LogFile struct {
	// The digest of the log contents.
	Digest *Digest `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	// This is a hint as to the purpose of the log, and is set to true if the log
	// is human-readable text that can be usefully displayed to a user, and false
	// otherwise. For instance, if a command-line client wishes to print the
	// server logs to the terminal for a failed action, this allows it to avoid
	// displaying a binary file.
	HumanReadable        bool     `protobuf:"varint,2,opt,name=human_readable,json=humanReadable,proto3" json:"human_readable,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogFile) Reset()         { *m = LogFile{} }
func (m *LogFile) String() string { return proto.CompactTextString(m) }
func (*LogFile) ProtoMessage()    {}
func (*LogFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{19}
}

func (m *LogFile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogFile.Unmarshal(m, b)
}
func (m *LogFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogFile.Marshal(b, m, deterministic)
}
func (m *LogFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFile.Merge(m, src)
}
func (m *LogFile) XXX_Size() int {
	return xxx_messageInfo_LogFile.Size(m)
}
func (m *LogFile) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFile.DiscardUnknown(m)
}

var xxx_messageInfo_LogFile proto.InternalMessageInfo

func (m *LogFile) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *LogFile) GetHumanReadable() bool {
	if m != nil {
		return m.HumanReadable
	}
	return false
}

// The response message for
// [Execution.Execute][build.bazel.remote.execution.v2.Execution.Execute],
// which will be contained in the [response
// field][google.longrunning.Operation.response] of the
// [Operation][google.longrunning.Operation].
type ExecuteResponse struct {
	// The result of the action.
	Result *ActionResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// True if the result was served from cache, false if it was executed.
	CachedResult bool `protobuf:"varint,2,opt,name=cached_result,json=cachedResult,proto3" json:"cached_result,omitempty"`
	// If the status has a code other than `OK`, it indicates that the action did
	// not finish execution. For example, if the operation times out during
	// execution, the status will have a `DEADLINE_EXCEEDED` code. Servers MUST
	// use this field for errors in execution, rather than the error field on the
	// `Operation` object.
	//
	// If the status code is other than `OK`, then the result MUST NOT be cached.
	// For an error status, the `result` field is optional; the server may
	// populate the output-, stdout-, and stderr-related fields if it has any
	// information available, such as the stdout and stderr of a timed-out action.
	Status *status.Status `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// An optional list of additional log outputs the server wishes to provide. A
	// server can use this to return execution-specific logs however it wishes.
	// This is intended primarily to make it easier for users to debug issues that
	// may be outside of the actual job execution, such as by identifying the
	// worker executing the action or by providing logs from the worker's setup
	// phase. The keys SHOULD be human readable so that a client can display them
	// to a user.
	ServerLogs map[string]*LogFile `protobuf:"bytes,4,rep,name=server_logs,json=serverLogs,proto3" json:"server_logs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Freeform informational message with details on the execution of the action
	// that may be displayed to the user upon failure or when requested explicitly.
	Message              string   `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteResponse) Reset()         { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()    {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{20}
}

func (m *ExecuteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteResponse.Unmarshal(m, b)
}
func (m *ExecuteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteResponse.Marshal(b, m, deterministic)
}
func (m *ExecuteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteResponse.Merge(m, src)
}
func (m *ExecuteResponse) XXX_Size() int {
	return xxx_messageInfo_ExecuteResponse.Size(m)
}
func (m *ExecuteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteResponse proto.InternalMessageInfo

func (m *ExecuteResponse) GetResult() *ActionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ExecuteResponse) GetCachedResult() bool {
	if m != nil {
		return m.CachedResult
	}
	return false
}

func (m *ExecuteResponse) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ExecuteResponse) GetServerLogs() map[string]*LogFile {
	if m != nil {
		return m.ServerLogs
	}
	return nil
}

func (m *ExecuteResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// The current stage of action execution.
type ExecutionStage struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecutionStage) Reset()         { *m = ExecutionStage{} }
func (m *ExecutionStage) String() string { return proto.CompactTextString(m) }
func (*ExecutionStage) ProtoMessage()    {}
func (*ExecutionStage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{21}
}

func (m *ExecutionStage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecutionStage.Unmarshal(m, b)
}
func (m *ExecutionStage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecutionStage.Marshal(b, m, deterministic)
}
func (m *ExecutionStage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionStage.Merge(m, src)
}
func (m *ExecutionStage) XXX_Size() int {
	return xxx_messageInfo_ExecutionStage.Size(m)
}
func (m *ExecutionStage) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionStage.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionStage proto.InternalMessageInfo

// Metadata about an ongoing
// [execution][build.bazel.remote.execution.v2.Execution.Execute], which
// will be contained in the [metadata
// field][google.longrunning.Operation.response] of the
// [Operation][google.longrunning.Operation].
type ExecuteOperationMetadata struct {
	// The current stage of execution.
	Stage ExecutionStage_Value `protobuf:"varint,1,opt,name=stage,proto3,enum=build.bazel.remote.execution.v2.ExecutionStage_Value" json:"stage,omitempty"`
	// The digest of the [Action][build.bazel.remote.execution.v2.Action]
	// being executed.
	ActionDigest *Digest `protobuf:"bytes,2,opt,name=action_digest,json=actionDigest,proto3" json:"action_digest,omitempty"`
	// If set, the client can use this resource name with
	// [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
	// standard output from the endpoint hosting streamed responses.
	StdoutStreamName string `protobuf:"bytes,3,opt,name=stdout_stream_name,json=stdoutStreamName,proto3" json:"stdout_stream_name,omitempty"`
	// If set, the client can use this resource name with
	// [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
	// standard error from the endpoint hosting streamed responses.
	StderrStreamName     string   `protobuf:"bytes,4,opt,name=stderr_stream_name,json=stderrStreamName,proto3" json:"stderr_stream_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteOperationMetadata) Reset()         { *m = ExecuteOperationMetadata{} }
func (m *ExecuteOperationMetadata) String() string { return proto.CompactTextString(m) }
func (*ExecuteOperationMetadata) ProtoMessage()    {}
func (*ExecuteOperationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{22}
}

func (m *ExecuteOperationMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecuteOperationMetadata.Unmarshal(m, b)
}
func (m *ExecuteOperationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecuteOperationMetadata.Marshal(b, m, deterministic)
}
func (m *ExecuteOperationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteOperationMetadata.Merge(m, src)
}
func (m *ExecuteOperationMetadata) XXX_Size() int {
	return xxx_messageInfo_ExecuteOperationMetadata.Size(m)
}
func (m *ExecuteOperationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteOperationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteOperationMetadata proto.InternalMessageInfo

func (m *ExecuteOperationMetadata) GetStage() ExecutionStage_Value {
	if m != nil {
		return m.Stage
	}
	return ExecutionStage_UNKNOWN
}

func (m *ExecuteOperationMetadata) GetActionDigest() *Digest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

func (m *ExecuteOperationMetadata) GetStdoutStreamName() string {
	if m != nil {
		return m.StdoutStreamName
	}
	return ""
}

func (m *ExecuteOperationMetadata) GetStderrStreamName() string {
	if m != nil {
		return m.StderrStreamName
	}
	return ""
}

// A request message for
// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution].
type WaitExecutionRequest struct {
	// The name of the [Operation][google.longrunning.Operation]
	// returned by [Execute][build.bazel.remote.execution.v2.Execution.Execute].
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WaitExecutionRequest) Reset()         { *m = WaitExecutionRequest{} }
func (m *WaitExecutionRequest) String() string { return proto.CompactTextString(m) }
func (*WaitExecutionRequest) ProtoMessage()    {}
func (*WaitExecutionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{23}
}

func (m *WaitExecutionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WaitExecutionRequest.Unmarshal(m, b)
}
func (m *WaitExecutionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WaitExecutionRequest.Marshal(b, m, deterministic)
}
func (m *WaitExecutionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaitExecutionRequest.Merge(m, src)
}
func (m *WaitExecutionRequest) XXX_Size() int {
	return xxx_messageInfo_WaitExecutionRequest.Size(m)
}
func (m *WaitExecutionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WaitExecutionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WaitExecutionRequest proto.InternalMessageInfo

func (m *WaitExecutionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A request message for
// [ActionCache.GetActionResult][build.bazel.remote.execution.v2.ActionCache.GetActionResult].
type GetActionResultRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The digest of the [Action][build.bazel.remote.execution.v2.Action]
	// whose result is requested.
	ActionDigest *Digest `protobuf:"bytes,2,opt,name=action_digest,json=actionDigest,proto3" json:"action_digest,omitempty"`
	// A hint to the server to request inlining stdout in the
	// [ActionResult][build.bazel.remote.execution.v2.ActionResult] message.
	InlineStdout bool `protobuf:"varint,3,opt,name=inline_stdout,json=inlineStdout,proto3" json:"inline_stdout,omitempty"`
	// A hint to the server to request inlining stderr in the
	// [ActionResult][build.bazel.remote.execution.v2.ActionResult] message.
	InlineStderr bool `protobuf:"varint,4,opt,name=inline_stderr,json=inlineStderr,proto3" json:"inline_stderr,omitempty"`
	// A hint to the server to inline the contents of the listed output files.
	// Each path needs to exactly match one file path in either `output_paths` or
	// `output_files` (DEPRECATED since v2.1) in the
	// [Command][build.bazel.remote.execution.v2.Command] message.
	InlineOutputFiles    []string `protobuf:"bytes,5,rep,name=inline_output_files,json=inlineOutputFiles,proto3" json:"inline_output_files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetActionResultRequest) Reset()         { *m = GetActionResultRequest{} }
func (m *GetActionResultRequest) String() string { return proto.CompactTextString(m) }
func (*GetActionResultRequest) ProtoMessage()    {}
func (*GetActionResultRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{24}
}

func (m *GetActionResultRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetActionResultRequest.Unmarshal(m, b)
}
func (m *GetActionResultRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetActionResultRequest.Marshal(b, m, deterministic)
}
func (m *GetActionResultRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActionResultRequest.Merge(m, src)
}
func (m *GetActionResultRequest) XXX_Size() int {
	return xxx_messageInfo_GetActionResultRequest.Size(m)
}
func (m *GetActionResultRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActionResultRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetActionResultRequest proto.InternalMessageInfo

func (m *GetActionResultRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *GetActionResultRequest) GetActionDigest() *Digest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

func (m *GetActionResultRequest) GetInlineStdout() bool {
	if m != nil {
		return m.InlineStdout
	}
	return false
}

func (m *GetActionResultRequest) GetInlineStderr() bool {
	if m != nil {
		return m.InlineStderr
	}
	return false
}

func (m *GetActionResultRequest) GetInlineOutputFiles() []string {
	if m != nil {
		return m.InlineOutputFiles
	}
	return nil
}

// A request message for
// [ActionCache.UpdateActionResult][build.bazel.remote.execution.v2.ActionCache.UpdateActionResult].
type UpdateActionResultRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The digest of the [Action][build.bazel.remote.execution.v2.Action]
	// whose result is being uploaded.
	ActionDigest *Digest `protobuf:"bytes,2,opt,name=action_digest,json=actionDigest,proto3" json:"action_digest,omitempty"`
	// The [ActionResult][build.bazel.remote.execution.v2.ActionResult]
	// to store in the cache.
	ActionResult *ActionResult `protobuf:"bytes,3,opt,name=action_result,json=actionResult,proto3" json:"action_result,omitempty"`
	// An optional policy for the results of this execution in the remote cache.
	// The server will have a default policy if this is not provided.
	// This may be applied to both the ActionResult and the associated blobs.
	ResultsCachePolicy   *ResultsCachePolicy `protobuf:"bytes,4,opt,name=results_cache_policy,json=resultsCachePolicy,proto3" json:"results_cache_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *UpdateActionResultRequest) Reset()         { *m = UpdateActionResultRequest{} }
func (m *UpdateActionResultRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateActionResultRequest) ProtoMessage()    {}
func (*UpdateActionResultRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{25}
}

func (m *UpdateActionResultRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateActionResultRequest.Unmarshal(m, b)
}
func (m *UpdateActionResultRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateActionResultRequest.Marshal(b, m, deterministic)
}
func (m *UpdateActionResultRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateActionResultRequest.Merge(m, src)
}
func (m *UpdateActionResultRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateActionResultRequest.Size(m)
}
func (m *UpdateActionResultRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateActionResultRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateActionResultRequest proto.InternalMessageInfo

func (m *UpdateActionResultRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *UpdateActionResultRequest) GetActionDigest() *Digest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

func (m *UpdateActionResultRequest) GetActionResult() *ActionResult {
	if m != nil {
		return m.ActionResult
	}
	return nil
}

func (m *UpdateActionResultRequest) GetResultsCachePolicy() *ResultsCachePolicy {
	if m != nil {
		return m.ResultsCachePolicy
	}
	return nil
}

// A request message for
// [ContentAddressableStorage.FindMissingBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.FindMissingBlobs].
type FindMissingBlobsRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// A list of the blobs to check.
	BlobDigests          []*Digest `protobuf:"bytes,2,rep,name=blob_digests,json=blobDigests,proto3" json:"blob_digests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FindMissingBlobsRequest) Reset()         { *m = FindMissingBlobsRequest{} }
func (m *FindMissingBlobsRequest) String() string { return proto.CompactTextString(m) }
func (*FindMissingBlobsRequest) ProtoMessage()    {}
func (*FindMissingBlobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{26}
}

func (m *FindMissingBlobsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FindMissingBlobsRequest.Unmarshal(m, b)
}
func (m *FindMissingBlobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FindMissingBlobsRequest.Marshal(b, m, deterministic)
}
func (m *FindMissingBlobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindMissingBlobsRequest.Merge(m, src)
}
func (m *FindMissingBlobsRequest) XXX_Size() int {
	return xxx_messageInfo_FindMissingBlobsRequest.Size(m)
}
func (m *FindMissingBlobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindMissingBlobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindMissingBlobsRequest proto.InternalMessageInfo

func (m *FindMissingBlobsRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *FindMissingBlobsRequest) GetBlobDigests() []*Digest {
	if m != nil {
		return m.BlobDigests
	}
	return nil
}

// A response message for
// [ContentAddressableStorage.FindMissingBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.FindMissingBlobs].
type FindMissingBlobsResponse struct {
	// A list of the blobs requested *not* present in the storage.
	MissingBlobDigests   []*Digest `protobuf:"bytes,2,rep,name=missing_blob_digests,json=missingBlobDigests,proto3" json:"missing_blob_digests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FindMissingBlobsResponse) Reset()         { *m = FindMissingBlobsResponse{} }
func (m *FindMissingBlobsResponse) String() string { return proto.CompactTextString(m) }
func (*FindMissingBlobsResponse) ProtoMessage()    {}
func (*FindMissingBlobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{27}
}

func (m *FindMissingBlobsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FindMissingBlobsResponse.Unmarshal(m, b)
}
func (m *FindMissingBlobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FindMissingBlobsResponse.Marshal(b, m, deterministic)
}
func (m *FindMissingBlobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindMissingBlobsResponse.Merge(m, src)
}
func (m *FindMissingBlobsResponse) XXX_Size() int {
	return xxx_messageInfo_FindMissingBlobsResponse.Size(m)
}
func (m *FindMissingBlobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindMissingBlobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindMissingBlobsResponse proto.InternalMessageInfo

func (m *FindMissingBlobsResponse) GetMissingBlobDigests() []*Digest {
	if m != nil {
		return m.MissingBlobDigests
	}
	return nil
}

// A request message for
// [ContentAddressableStorage.BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
type BatchUpdateBlobsRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The individual upload requests.
	Requests             []*BatchUpdateBlobsRequest_Request `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *BatchUpdateBlobsRequest) Reset()         { *m = BatchUpdateBlobsRequest{} }
func (m *BatchUpdateBlobsRequest) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBlobsRequest) ProtoMessage()    {}
func (*BatchUpdateBlobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{28}
}

func (m *BatchUpdateBlobsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBlobsRequest.Unmarshal(m, b)
}
func (m *BatchUpdateBlobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBlobsRequest.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBlobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBlobsRequest.Merge(m, src)
}
func (m *BatchUpdateBlobsRequest) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBlobsRequest.Size(m)
}
func (m *BatchUpdateBlobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBlobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBlobsRequest proto.InternalMessageInfo

func (m *BatchUpdateBlobsRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *BatchUpdateBlobsRequest) GetRequests() []*BatchUpdateBlobsRequest_Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

// A request corresponding to a single blob that the client wants to upload.
type BatchUpdateBlobsRequest_Request struct {
	// The digest of the blob. This MUST be the digest of `data`.
	Digest *Digest `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	// The raw binary data.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchUpdateBlobsRequest_Request) Reset()         { *m = BatchUpdateBlobsRequest_Request{} }
func (m *BatchUpdateBlobsRequest_Request) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBlobsRequest_Request) ProtoMessage()    {}
func (*BatchUpdateBlobsRequest_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{28, 0}
}

func (m *BatchUpdateBlobsRequest_Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBlobsRequest_Request.Unmarshal(m, b)
}
func (m *BatchUpdateBlobsRequest_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBlobsRequest_Request.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBlobsRequest_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBlobsRequest_Request.Merge(m, src)
}
func (m *BatchUpdateBlobsRequest_Request) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBlobsRequest_Request.Size(m)
}
func (m *BatchUpdateBlobsRequest_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBlobsRequest_Request.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBlobsRequest_Request proto.InternalMessageInfo

func (m *BatchUpdateBlobsRequest_Request) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *BatchUpdateBlobsRequest_Request) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// A response message for
// [ContentAddressableStorage.BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
type BatchUpdateBlobsResponse struct {
	// The responses to the requests.
	Responses            []*BatchUpdateBlobsResponse_Response `protobuf:"bytes,1,rep,name=responses,proto3" json:"responses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *BatchUpdateBlobsResponse) Reset()         { *m = BatchUpdateBlobsResponse{} }
func (m *BatchUpdateBlobsResponse) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBlobsResponse) ProtoMessage()    {}
func (*BatchUpdateBlobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{29}
}

func (m *BatchUpdateBlobsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBlobsResponse.Unmarshal(m, b)
}
func (m *BatchUpdateBlobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBlobsResponse.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBlobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBlobsResponse.Merge(m, src)
}
func (m *BatchUpdateBlobsResponse) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBlobsResponse.Size(m)
}
func (m *BatchUpdateBlobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBlobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBlobsResponse proto.InternalMessageInfo

func (m *BatchUpdateBlobsResponse) GetResponses() []*BatchUpdateBlobsResponse_Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

// A response corresponding to a single blob that the client tried to upload.
type BatchUpdateBlobsResponse_Response struct {
	// The blob digest to which this response corresponds.
	Digest *Digest `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	// The result of attempting to upload that blob.
	Status               *status.Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchUpdateBlobsResponse_Response) Reset()         { *m = BatchUpdateBlobsResponse_Response{} }
func (m *BatchUpdateBlobsResponse_Response) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateBlobsResponse_Response) ProtoMessage()    {}
func (*BatchUpdateBlobsResponse_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{29, 0}
}

func (m *BatchUpdateBlobsResponse_Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateBlobsResponse_Response.Unmarshal(m, b)
}
func (m *BatchUpdateBlobsResponse_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateBlobsResponse_Response.Marshal(b, m, deterministic)
}
func (m *BatchUpdateBlobsResponse_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateBlobsResponse_Response.Merge(m, src)
}
func (m *BatchUpdateBlobsResponse_Response) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateBlobsResponse_Response.Size(m)
}
func (m *BatchUpdateBlobsResponse_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateBlobsResponse_Response.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateBlobsResponse_Response proto.InternalMessageInfo

func (m *BatchUpdateBlobsResponse_Response) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *BatchUpdateBlobsResponse_Response) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// A request message for
// [ContentAddressableStorage.BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
type BatchReadBlobsRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The individual blob digests.
	Digests              []*Digest `protobuf:"bytes,2,rep,name=digests,proto3" json:"digests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BatchReadBlobsRequest) Reset()         { *m = BatchReadBlobsRequest{} }
func (m *BatchReadBlobsRequest) String() string { return proto.CompactTextString(m) }
func (*BatchReadBlobsRequest) ProtoMessage()    {}
func (*BatchReadBlobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{30}
}

func (m *BatchReadBlobsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchReadBlobsRequest.Unmarshal(m, b)
}
func (m *BatchReadBlobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchReadBlobsRequest.Marshal(b, m, deterministic)
}
func (m *BatchReadBlobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReadBlobsRequest.Merge(m, src)
}
func (m *BatchReadBlobsRequest) XXX_Size() int {
	return xxx_messageInfo_BatchReadBlobsRequest.Size(m)
}
func (m *BatchReadBlobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReadBlobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReadBlobsRequest proto.InternalMessageInfo

func (m *BatchReadBlobsRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *BatchReadBlobsRequest) GetDigests() []*Digest {
	if m != nil {
		return m.Digests
	}
	return nil
}

// A response message for
// [ContentAddressableStorage.BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
type BatchReadBlobsResponse struct {
	// The responses to the requests.
	Responses            []*BatchReadBlobsResponse_Response `protobuf:"bytes,1,rep,name=responses,proto3" json:"responses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *BatchReadBlobsResponse) Reset()         { *m = BatchReadBlobsResponse{} }
func (m *BatchReadBlobsResponse) String() string { return proto.CompactTextString(m) }
func (*BatchReadBlobsResponse) ProtoMessage()    {}
func (*BatchReadBlobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{31}
}

func (m *BatchReadBlobsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchReadBlobsResponse.Unmarshal(m, b)
}
func (m *BatchReadBlobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchReadBlobsResponse.Marshal(b, m, deterministic)
}
func (m *BatchReadBlobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReadBlobsResponse.Merge(m, src)
}
func (m *BatchReadBlobsResponse) XXX_Size() int {
	return xxx_messageInfo_BatchReadBlobsResponse.Size(m)
}
func (m *BatchReadBlobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReadBlobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReadBlobsResponse proto.InternalMessageInfo

func (m *BatchReadBlobsResponse) GetResponses() []*BatchReadBlobsResponse_Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

// A response corresponding to a single blob that the client tried to download.
type BatchReadBlobsResponse_Response struct {
	// The digest to which this response corresponds.
	Digest *Digest `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	// The raw binary data.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The result of attempting to download that blob.
	Status               *status.Status `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchReadBlobsResponse_Response) Reset()         { *m = BatchReadBlobsResponse_Response{} }
func (m *BatchReadBlobsResponse_Response) String() string { return proto.CompactTextString(m) }
func (*BatchReadBlobsResponse_Response) ProtoMessage()    {}
func (*BatchReadBlobsResponse_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{31, 0}
}

func (m *BatchReadBlobsResponse_Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchReadBlobsResponse_Response.Unmarshal(m, b)
}
func (m *BatchReadBlobsResponse_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchReadBlobsResponse_Response.Marshal(b, m, deterministic)
}
func (m *BatchReadBlobsResponse_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReadBlobsResponse_Response.Merge(m, src)
}
func (m *BatchReadBlobsResponse_Response) XXX_Size() int {
	return xxx_messageInfo_BatchReadBlobsResponse_Response.Size(m)
}
func (m *BatchReadBlobsResponse_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReadBlobsResponse_Response.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReadBlobsResponse_Response proto.InternalMessageInfo

func (m *BatchReadBlobsResponse_Response) GetDigest() *Digest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *BatchReadBlobsResponse_Response) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BatchReadBlobsResponse_Response) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// A request message for
// [ContentAddressableStorage.GetTree][build.bazel.remote.execution.v2.ContentAddressableStorage.GetTree].
type GetTreeRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The digest of the root, which must be an encoded
	// [Directory][build.bazel.remote.execution.v2.Directory] message
	// stored in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	RootDigest *Digest `protobuf:"bytes,2,opt,name=root_digest,json=rootDigest,proto3" json:"root_digest,omitempty"`
	// A maximum page size to request. If present, the server will request no more
	// than this many items. Regardless of whether a page size is specified, the
	// server may place its own limit on the number of items to be returned and
	// require the client to retrieve more items using a subsequent request.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, which must be a value received in a previous
	// [GetTreeResponse][build.bazel.remote.execution.v2.GetTreeResponse].
	// If present, the server will use that token as an offset, returning only
	// that page and the ones that succeed it.
	PageToken            string   `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTreeRequest) Reset()         { *m = GetTreeRequest{} }
func (m *GetTreeRequest) String() string { return proto.CompactTextString(m) }
func (*GetTreeRequest) ProtoMessage()    {}
func (*GetTreeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{32}
}

func (m *GetTreeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTreeRequest.Unmarshal(m, b)
}
func (m *GetTreeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTreeRequest.Marshal(b, m, deterministic)
}
func (m *GetTreeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTreeRequest.Merge(m, src)
}
func (m *GetTreeRequest) XXX_Size() int {
	return xxx_messageInfo_GetTreeRequest.Size(m)
}
func (m *GetTreeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTreeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTreeRequest proto.InternalMessageInfo

func (m *GetTreeRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *GetTreeRequest) GetRootDigest() *Digest {
	if m != nil {
		return m.RootDigest
	}
	return nil
}

func (m *GetTreeRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *GetTreeRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// A response message for
// [ContentAddressableStorage.GetTree][build.bazel.remote.execution.v2.ContentAddressableStorage.GetTree].
type GetTreeResponse struct {
	// The directories descended from the requested root.
	Directories []*Directory `protobuf:"bytes,1,rep,name=directories,proto3" json:"directories,omitempty"`
	// If present, signifies that there are more results which the client can
	// retrieve by passing this as the page_token in a subsequent
	// [request][build.bazel.remote.execution.v2.GetTreeRequest].
	// If empty, signifies that this is the last page of results.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTreeResponse) Reset()         { *m = GetTreeResponse{} }
func (m *GetTreeResponse) String() string { return proto.CompactTextString(m) }
func (*GetTreeResponse) ProtoMessage()    {}
func (*GetTreeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{33}
}

func (m *GetTreeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTreeResponse.Unmarshal(m, b)
}
func (m *GetTreeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTreeResponse.Marshal(b, m, deterministic)
}
func (m *GetTreeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTreeResponse.Merge(m, src)
}
func (m *GetTreeResponse) XXX_Size() int {
	return xxx_messageInfo_GetTreeResponse.Size(m)
}
func (m *GetTreeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTreeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTreeResponse proto.InternalMessageInfo

func (m *GetTreeResponse) GetDirectories() []*Directory {
	if m != nil {
		return m.Directories
	}
	return nil
}

func (m *GetTreeResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// A request message for
// [Capabilities.GetCapabilities][build.bazel.remote.execution.v2.Capabilities.GetCapabilities].
type GetCapabilitiesRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName         string   `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCapabilitiesRequest) Reset()         { *m = GetCapabilitiesRequest{} }
func (m *GetCapabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*GetCapabilitiesRequest) ProtoMessage()    {}
func (*GetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{34}
}

func (m *GetCapabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCapabilitiesRequest.Unmarshal(m, b)
}
func (m *GetCapabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCapabilitiesRequest.Marshal(b, m, deterministic)
}
func (m *GetCapabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCapabilitiesRequest.Merge(m, src)
}
func (m *GetCapabilitiesRequest) XXX_Size() int {
	return xxx_messageInfo_GetCapabilitiesRequest.Size(m)
}
func (m *GetCapabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCapabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCapabilitiesRequest proto.InternalMessageInfo

func (m *GetCapabilitiesRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

// A response message for
// [Capabilities.GetCapabilities][build.bazel.remote.execution.v2.Capabilities.GetCapabilities].
type ServerCapabilities struct {
	// Capabilities of the remote cache system.
	CacheCapabilities *CacheCapabilities `protobuf:"bytes,1,opt,name=cache_capabilities,json=cacheCapabilities,proto3" json:"cache_capabilities,omitempty"`
	// Capabilities of the remote execution system.
	ExecutionCapabilities *ExecutionCapabilities `protobuf:"bytes,2,opt,name=execution_capabilities,json=executionCapabilities,proto3" json:"execution_capabilities,omitempty"`
	// Earliest RE API version supported, including deprecated versions.
	DeprecatedApiVersion *semver.SemVer `protobuf:"bytes,3,opt,name=deprecated_api_version,json=deprecatedApiVersion,proto3" json:"deprecated_api_version,omitempty"`
	// Earliest non-deprecated RE API version supported.
	LowApiVersion *semver.SemVer `protobuf:"bytes,4,opt,name=low_api_version,json=lowApiVersion,proto3" json:"low_api_version,omitempty"`
	// Latest RE API version supported.
	HighApiVersion       *semver.SemVer `protobuf:"bytes,5,opt,name=high_api_version,json=highApiVersion,proto3" json:"high_api_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ServerCapabilities) Reset()         { *m = ServerCapabilities{} }
func (m *ServerCapabilities) String() string { return proto.CompactTextString(m) }
func (*ServerCapabilities) ProtoMessage()    {}
func (*ServerCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{35}
}

func (m *ServerCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerCapabilities.Unmarshal(m, b)
}
func (m *ServerCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerCapabilities.Marshal(b, m, deterministic)
}
func (m *ServerCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerCapabilities.Merge(m, src)
}
func (m *ServerCapabilities) XXX_Size() int {
	return xxx_messageInfo_ServerCapabilities.Size(m)
}
func (m *ServerCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ServerCapabilities proto.InternalMessageInfo

func (m *ServerCapabilities) GetCacheCapabilities() *CacheCapabilities {
	if m != nil {
		return m.CacheCapabilities
	}
	return nil
}

func (m *ServerCapabilities) GetExecutionCapabilities() *ExecutionCapabilities {
	if m != nil {
		return m.ExecutionCapabilities
	}
	return nil
}

func (m *ServerCapabilities) GetDeprecatedApiVersion() *semver.SemVer {
	if m != nil {
		return m.DeprecatedApiVersion
	}
	return nil
}

func (m *ServerCapabilities) GetLowApiVersion() *semver.SemVer {
	if m != nil {
		return m.LowApiVersion
	}
	return nil
}

func (m *ServerCapabilities) GetHighApiVersion() *semver.SemVer {
	if m != nil {
		return m.HighApiVersion
	}
	return nil
}

// The digest function used for converting values into keys for CAS and Action
// Cache.
type DigestFunction struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestFunction) Reset()         { *m = DigestFunction{} }
func (m *DigestFunction) String() string { return proto.CompactTextString(m) }
func (*DigestFunction) ProtoMessage()    {}
func (*DigestFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{36}
}

func (m *DigestFunction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DigestFunction.Unmarshal(m, b)
}
func (m *DigestFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DigestFunction.Marshal(b, m, deterministic)
}
func (m *DigestFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestFunction.Merge(m, src)
}
func (m *DigestFunction) XXX_Size() int {
	return xxx_messageInfo_DigestFunction.Size(m)
}
func (m *DigestFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestFunction.DiscardUnknown(m)
}

var xxx_messageInfo_DigestFunction proto.InternalMessageInfo

// Describes the server/instance capabilities for updating the action cache.
type ActionCacheUpdateCapabilities struct {
	UpdateEnabled        bool     `protobuf:"varint,1,opt,name=update_enabled,json=updateEnabled,proto3" json:"update_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActionCacheUpdateCapabilities) Reset()         { *m = ActionCacheUpdateCapabilities{} }
func (m *ActionCacheUpdateCapabilities) String() string { return proto.CompactTextString(m) }
func (*ActionCacheUpdateCapabilities) ProtoMessage()    {}
func (*ActionCacheUpdateCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{37}
}

func (m *ActionCacheUpdateCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ActionCacheUpdateCapabilities.Unmarshal(m, b)
}
func (m *ActionCacheUpdateCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ActionCacheUpdateCapabilities.Marshal(b, m, deterministic)
}
func (m *ActionCacheUpdateCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCacheUpdateCapabilities.Merge(m, src)
}
func (m *ActionCacheUpdateCapabilities) XXX_Size() int {
	return xxx_messageInfo_ActionCacheUpdateCapabilities.Size(m)
}
func (m *ActionCacheUpdateCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCacheUpdateCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCacheUpdateCapabilities proto.InternalMessageInfo

func (m *ActionCacheUpdateCapabilities) GetUpdateEnabled() bool {
	if m != nil {
		return m.UpdateEnabled
	}
	return false
}

// Allowed values for priority in
// [ResultsCachePolicy][build.bazel.remoteexecution.v2.ResultsCachePolicy] and
// [ExecutionPolicy][build.bazel.remoteexecution.v2.ResultsCachePolicy]
// Used for querying both cache and execution valid priority ranges.
type PriorityCapabilities struct {
	Priorities           []*PriorityCapabilities_PriorityRange `protobuf:"bytes,1,rep,name=priorities,proto3" json:"priorities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *PriorityCapabilities) Reset()         { *m = PriorityCapabilities{} }
func (m *PriorityCapabilities) String() string { return proto.CompactTextString(m) }
func (*PriorityCapabilities) ProtoMessage()    {}
func (*PriorityCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{38}
}

func (m *PriorityCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriorityCapabilities.Unmarshal(m, b)
}
func (m *PriorityCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriorityCapabilities.Marshal(b, m, deterministic)
}
func (m *PriorityCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriorityCapabilities.Merge(m, src)
}
func (m *PriorityCapabilities) XXX_Size() int {
	return xxx_messageInfo_PriorityCapabilities.Size(m)
}
func (m *PriorityCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_PriorityCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_PriorityCapabilities proto.InternalMessageInfo

func (m *PriorityCapabilities) GetPriorities() []*PriorityCapabilities_PriorityRange {
	if m != nil {
		return m.Priorities
	}
	return nil
}

// Supported range of priorities, including boundaries.
type PriorityCapabilities_PriorityRange struct {
	// The minimum numeric value for this priority range, which represents the
	// most urgent task or longest retained item.
	MinPriority int32 `protobuf:"varint,1,opt,name=min_priority,json=minPriority,proto3" json:"min_priority,omitempty"`
	// The maximum numeric value for this priority range, which represents the
	// least urgent task or shortest retained item.
	MaxPriority          int32    `protobuf:"varint,2,opt,name=max_priority,json=maxPriority,proto3" json:"max_priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PriorityCapabilities_PriorityRange) Reset()         { *m = PriorityCapabilities_PriorityRange{} }
func (m *PriorityCapabilities_PriorityRange) String() string { return proto.CompactTextString(m) }
func (*PriorityCapabilities_PriorityRange) ProtoMessage()    {}
func (*PriorityCapabilities_PriorityRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{38, 0}
}

func (m *PriorityCapabilities_PriorityRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PriorityCapabilities_PriorityRange.Unmarshal(m, b)
}
func (m *PriorityCapabilities_PriorityRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PriorityCapabilities_PriorityRange.Marshal(b, m, deterministic)
}
func (m *PriorityCapabilities_PriorityRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriorityCapabilities_PriorityRange.Merge(m, src)
}
func (m *PriorityCapabilities_PriorityRange) XXX_Size() int {
	return xxx_messageInfo_PriorityCapabilities_PriorityRange.Size(m)
}
func (m *PriorityCapabilities_PriorityRange) XXX_DiscardUnknown() {
	xxx_messageInfo_PriorityCapabilities_PriorityRange.DiscardUnknown(m)
}

var xxx_messageInfo_PriorityCapabilities_PriorityRange proto.InternalMessageInfo

func (m *PriorityCapabilities_PriorityRange) GetMinPriority() int32 {
	if m != nil {
		return m.MinPriority
	}
	return 0
}

func (m *PriorityCapabilities_PriorityRange) GetMaxPriority() int32 {
	if m != nil {
		return m.MaxPriority
	}
	return 0
}

// Describes how the server treats absolute symlink targets.
type SymlinkAbsolutePathStrategy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SymlinkAbsolutePathStrategy) Reset()         { *m = SymlinkAbsolutePathStrategy{} }
func (m *SymlinkAbsolutePathStrategy) String() string { return proto.CompactTextString(m) }
func (*SymlinkAbsolutePathStrategy) ProtoMessage()    {}
func (*SymlinkAbsolutePathStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{39}
}

func (m *SymlinkAbsolutePathStrategy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SymlinkAbsolutePathStrategy.Unmarshal(m, b)
}
func (m *SymlinkAbsolutePathStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SymlinkAbsolutePathStrategy.Marshal(b, m, deterministic)
}
func (m *SymlinkAbsolutePathStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymlinkAbsolutePathStrategy.Merge(m, src)
}
func (m *SymlinkAbsolutePathStrategy) XXX_Size() int {
	return xxx_messageInfo_SymlinkAbsolutePathStrategy.Size(m)
}
func (m *SymlinkAbsolutePathStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_SymlinkAbsolutePathStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_SymlinkAbsolutePathStrategy proto.InternalMessageInfo

// Compression formats which may be supported.
type Compressor struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Compressor) Reset()         { *m = Compressor{} }
func (m *Compressor) String() string { return proto.CompactTextString(m) }
func (*Compressor) ProtoMessage()    {}
func (*Compressor) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{40}
}

func (m *Compressor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Compressor.Unmarshal(m, b)
}
func (m *Compressor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Compressor.Marshal(b, m, deterministic)
}
func (m *Compressor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Compressor.Merge(m, src)
}
func (m *Compressor) XXX_Size() int {
	return xxx_messageInfo_Compressor.Size(m)
}
func (m *Compressor) XXX_DiscardUnknown() {
	xxx_messageInfo_Compressor.DiscardUnknown(m)
}

var xxx_messageInfo_Compressor proto.InternalMessageInfo

// Capabilities of the remote cache system.
type CacheCapabilities struct {
	// All the digest functions supported by the remote cache.
	// Remote cache may support multiple digest functions simultaneously.
	DigestFunction []DigestFunction_Value `protobuf:"varint,1,rep,packed,name=digest_function,json=digestFunction,proto3,enum=build.bazel.remote.execution.v2.DigestFunction_Value" json:"digest_function,omitempty"`
	// Capabilities for updating the action cache.
	ActionCacheUpdateCapabilities *ActionCacheUpdateCapabilities `protobuf:"bytes,2,opt,name=action_cache_update_capabilities,json=actionCacheUpdateCapabilities,proto3" json:"action_cache_update_capabilities,omitempty"`
	// Supported cache priority range for both CAS and ActionCache.
	CachePriorityCapabilities *PriorityCapabilities `protobuf:"bytes,3,opt,name=cache_priority_capabilities,json=cachePriorityCapabilities,proto3" json:"cache_priority_capabilities,omitempty"`
	// Maximum total size of blobs to be uploaded/downloaded using
	// batch methods. A value of 0 means no limit is set, although
	// in practice there will always be a message size limitation
	// of the protocol in use, e.g. GRPC.
	MaxBatchTotalSizeBytes int64 `protobuf:"varint,4,opt,name=max_batch_total_size_bytes,json=maxBatchTotalSizeBytes,proto3" json:"max_batch_total_size_bytes,omitempty"`
	// Whether absolute symlink targets are supported.
	SymlinkAbsolutePathStrategy SymlinkAbsolutePathStrategy_Value `protobuf:"varint,5,opt,name=symlink_absolute_path_strategy,json=symlinkAbsolutePathStrategy,proto3,enum=build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy_Value" json:"symlink_absolute_path_strategy,omitempty"`
	// Compressors supported by the "compressed-blobs" bytestream resources.
	// Servers MUST support identity/no-compression, even if it is not listed
	// here.
	//
	// Note that this does not imply which if any compressors are supported by
	// the server at the gRPC level.
	SupportedCompressor  []Compressor_Value `protobuf:"varint,6,rep,packed,name=supported_compressor,json=supportedCompressor,proto3,enum=build.bazel.remote.execution.v2.Compressor_Value" json:"supported_compressor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CacheCapabilities) Reset()         { *m = CacheCapabilities{} }
func (m *CacheCapabilities) String() string { return proto.CompactTextString(m) }
func (*CacheCapabilities) ProtoMessage()    {}
func (*CacheCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{41}
}

func (m *CacheCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CacheCapabilities.Unmarshal(m, b)
}
func (m *CacheCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CacheCapabilities.Marshal(b, m, deterministic)
}
func (m *CacheCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheCapabilities.Merge(m, src)
}
func (m *CacheCapabilities) XXX_Size() int {
	return xxx_messageInfo_CacheCapabilities.Size(m)
}
func (m *CacheCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_CacheCapabilities proto.InternalMessageInfo

func (m *CacheCapabilities) GetDigestFunction() []DigestFunction_Value {
	if m != nil {
		return m.DigestFunction
	}
	return nil
}

func (m *CacheCapabilities) GetActionCacheUpdateCapabilities() *ActionCacheUpdateCapabilities {
	if m != nil {
		return m.ActionCacheUpdateCapabilities
	}
	return nil
}

func (m *CacheCapabilities) GetCachePriorityCapabilities() *PriorityCapabilities {
	if m != nil {
		return m.CachePriorityCapabilities
	}
	return nil
}

func (m *CacheCapabilities) GetMaxBatchTotalSizeBytes() int64 {
	if m != nil {
		return m.MaxBatchTotalSizeBytes
	}
	return 0
}

func (m *CacheCapabilities) GetSymlinkAbsolutePathStrategy() SymlinkAbsolutePathStrategy_Value {
	if m != nil {
		return m.SymlinkAbsolutePathStrategy
	}
	return SymlinkAbsolutePathStrategy_UNKNOWN
}

func (m *CacheCapabilities) GetSupportedCompressor() []Compressor_Value {
	if m != nil {
		return m.SupportedCompressor
	}
	return nil
}

// Capabilities of the remote execution system.
type ExecutionCapabilities struct {
	// Remote execution may only support a single digest function.
	DigestFunction DigestFunction_Value `protobuf:"varint,1,opt,name=digest_function,json=digestFunction,proto3,enum=build.bazel.remote.execution.v2.DigestFunction_Value" json:"digest_function,omitempty"`
	// Whether remote execution is enabled for the particular server/instance.
	ExecEnabled bool `protobuf:"varint,2,opt,name=exec_enabled,json=execEnabled,proto3" json:"exec_enabled,omitempty"`
	// Supported execution priority range.
	ExecutionPriorityCapabilities *PriorityCapabilities `protobuf:"bytes,3,opt,name=execution_priority_capabilities,json=executionPriorityCapabilities,proto3" json:"execution_priority_capabilities,omitempty"`
	// Supported node properties.
	SupportedNodeProperties []string `protobuf:"bytes,4,rep,name=supported_node_properties,json=supportedNodeProperties,proto3" json:"supported_node_properties,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ExecutionCapabilities) Reset()         { *m = ExecutionCapabilities{} }
func (m *ExecutionCapabilities) String() string { return proto.CompactTextString(m) }
func (*ExecutionCapabilities) ProtoMessage()    {}
func (*ExecutionCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{42}
}

func (m *ExecutionCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExecutionCapabilities.Unmarshal(m, b)
}
func (m *ExecutionCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExecutionCapabilities.Marshal(b, m, deterministic)
}
func (m *ExecutionCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionCapabilities.Merge(m, src)
}
func (m *ExecutionCapabilities) XXX_Size() int {
	return xxx_messageInfo_ExecutionCapabilities.Size(m)
}
func (m *ExecutionCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionCapabilities proto.InternalMessageInfo

func (m *ExecutionCapabilities) GetDigestFunction() DigestFunction_Value {
	if m != nil {
		return m.DigestFunction
	}
	return DigestFunction_UNKNOWN
}

func (m *ExecutionCapabilities) GetExecEnabled() bool {
	if m != nil {
		return m.ExecEnabled
	}
	return false
}

func (m *ExecutionCapabilities) GetExecutionPriorityCapabilities() *PriorityCapabilities {
	if m != nil {
		return m.ExecutionPriorityCapabilities
	}
	return nil
}

func (m *ExecutionCapabilities) GetSupportedNodeProperties() []string {
	if m != nil {
		return m.SupportedNodeProperties
	}
	return nil
}

// Details for the tool used to call the API.
type ToolDetails struct {
	// Name of the tool, e.g. bazel.
	ToolName string `protobuf:"bytes,1,opt,name=tool_name,json=toolName,proto3" json:"tool_name,omitempty"`
	// Version of the tool used for the request, e.g. 5.0.3.
	ToolVersion          string   `protobuf:"bytes,2,opt,name=tool_version,json=toolVersion,proto3" json:"tool_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ToolDetails) Reset()         { *m = ToolDetails{} }
func (m *ToolDetails) String() string { return proto.CompactTextString(m) }
func (*ToolDetails) ProtoMessage()    {}
func (*ToolDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{43}
}

func (m *ToolDetails) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ToolDetails.Unmarshal(m, b)
}
func (m *ToolDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ToolDetails.Marshal(b, m, deterministic)
}
func (m *ToolDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToolDetails.Merge(m, src)
}
func (m *ToolDetails) XXX_Size() int {
	return xxx_messageInfo_ToolDetails.Size(m)
}
func (m *ToolDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ToolDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ToolDetails proto.InternalMessageInfo

func (m *ToolDetails) GetToolName() string {
	if m != nil {
		return m.ToolName
	}
	return ""
}

func (m *ToolDetails) GetToolVersion() string {
	if m != nil {
		return m.ToolVersion
	}
	return ""
}

// An optional Metadata to attach to any RPC request to tell the server about an
// external context of the request. The server may use this for logging or other
// purposes. To use it, the client attaches the header to the call using the
// canonical proto serialization:
//
// * name: `build.bazel.remote.execution.v2.requestmetadata-bin`
// * contents: the base64 encoded binary `RequestMetadata` message.
// Note: the gRPC library serializes binary headers encoded in base 64 by
// default (https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests).
// Therefore, if the gRPC library is used to pass/retrieve this
// metadata, the user may ignore the base64 encoding and assume it is simply
// serialized as a binary message.
type RequestMetadata struct {
	// The details for the tool invoking the requests.
	ToolDetails *ToolDetails `protobuf:"bytes,1,opt,name=tool_details,json=toolDetails,proto3" json:"tool_details,omitempty"`
	// An identifier that ties multiple requests to the same action.
	// For example, multiple requests to the CAS, Action Cache, and Execution
	// API are used in order to compile foo.cc.
	ActionId string `protobuf:"bytes,2,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	// An identifier that ties multiple actions together to a final result.
	// For example, multiple actions are required to build and run foo_test.
	ToolInvocationId string `protobuf:"bytes,3,opt,name=tool_invocation_id,json=toolInvocationId,proto3" json:"tool_invocation_id,omitempty"`
	// An identifier to tie multiple tool invocations together. For example,
	// runs of foo_test, bar_test and baz_test on a post-submit of a given patch.
	CorrelatedInvocationsId string `protobuf:"bytes,4,opt,name=correlated_invocations_id,json=correlatedInvocationsId,proto3" json:"correlated_invocations_id,omitempty"`
	// A brief description of the kind of action, for example, CppCompile or GoLink.
	// There is no standard agreed set of values for this, and they are expected to vary between different client tools.
	ActionMnemonic string `protobuf:"bytes,5,opt,name=action_mnemonic,json=actionMnemonic,proto3" json:"action_mnemonic,omitempty"`
	// An identifier for the target which produced this action.
	// No guarantees are made around how many actions may relate to a single target.
	TargetId string `protobuf:"bytes,6,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	// An identifier for the configuration in which the target was built,
	// e.g. for differentiating building host tools or different target platforms.
	// There is no expectation that this value will have any particular structure,
	// or equality across invocations, though some client tools may offer these guarantees.
	ConfigurationId      string   `protobuf:"bytes,7,opt,name=configuration_id,json=configurationId,proto3" json:"configuration_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestMetadata) Reset()         { *m = RequestMetadata{} }
func (m *RequestMetadata) String() string { return proto.CompactTextString(m) }
func (*RequestMetadata) ProtoMessage()    {}
func (*RequestMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c43847ba40caac95, []int{44}
}

func (m *RequestMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestMetadata.Unmarshal(m, b)
}
func (m *RequestMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestMetadata.Marshal(b, m, deterministic)
}
func (m *RequestMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMetadata.Merge(m, src)
}
func (m *RequestMetadata) XXX_Size() int {
	return xxx_messageInfo_RequestMetadata.Size(m)
}
func (m *RequestMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMetadata proto.InternalMessageInfo

func (m *RequestMetadata) GetToolDetails() *ToolDetails {
	if m != nil {
		return m.ToolDetails
	}
	return nil
}

func (m *RequestMetadata) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *RequestMetadata) GetToolInvocationId() string {
	if m != nil {
		return m.ToolInvocationId
	}
	return ""
}

func (m *RequestMetadata) GetCorrelatedInvocationsId() string {
	if m != nil {
		return m.CorrelatedInvocationsId
	}
	return ""
}

func (m *RequestMetadata) GetActionMnemonic() string {
	if m != nil {
		return m.ActionMnemonic
	}
	return ""
}

func (m *RequestMetadata) GetTargetId() string {
	if m != nil {
		return m.TargetId
	}
	return ""
}

func (m *RequestMetadata) GetConfigurationId() string {
	if m != nil {
		return m.ConfigurationId
	}
	return ""
}

func init() {
	proto.RegisterEnum("build.bazel.remote.execution.v2.ExecutionStage_Value", ExecutionStage_Value_name, ExecutionStage_Value_value)
	proto.RegisterEnum("build.bazel.remote.execution.v2.DigestFunction_Value", DigestFunction_Value_name, DigestFunction_Value_value)
	proto.RegisterEnum("build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy_Value", SymlinkAbsolutePathStrategy_Value_name, SymlinkAbsolutePathStrategy_Value_value)
	proto.RegisterEnum("build.bazel.remote.execution.v2.Compressor_Value", Compressor_Value_name, Compressor_Value_value)
	proto.RegisterType((*Action)(nil), "build.bazel.remote.execution.v2.Action")
	proto.RegisterType((*Command)(nil), "build.bazel.remote.execution.v2.Command")
	proto.RegisterType((*Command_EnvironmentVariable)(nil), "build.bazel.remote.execution.v2.Command.EnvironmentVariable")
	proto.RegisterType((*Platform)(nil), "build.bazel.remote.execution.v2.Platform")
	proto.RegisterType((*Platform_Property)(nil), "build.bazel.remote.execution.v2.Platform.Property")
	proto.RegisterType((*Directory)(nil), "build.bazel.remote.execution.v2.Directory")
	proto.RegisterType((*NodeProperty)(nil), "build.bazel.remote.execution.v2.NodeProperty")
	proto.RegisterType((*NodeProperties)(nil), "build.bazel.remote.execution.v2.NodeProperties")
	proto.RegisterType((*FileNode)(nil), "build.bazel.remote.execution.v2.FileNode")
	proto.RegisterType((*DirectoryNode)(nil), "build.bazel.remote.execution.v2.DirectoryNode")
	proto.RegisterType((*SymlinkNode)(nil), "build.bazel.remote.execution.v2.SymlinkNode")
	proto.RegisterType((*Digest)(nil), "build.bazel.remote.execution.v2.Digest")
	proto.RegisterType((*ExecutedActionMetadata)(nil), "build.bazel.remote.execution.v2.ExecutedActionMetadata")
	proto.RegisterType((*ActionResult)(nil), "build.bazel.remote.execution.v2.ActionResult")
	proto.RegisterType((*OutputFile)(nil), "build.bazel.remote.execution.v2.OutputFile")
	proto.RegisterType((*Tree)(nil), "build.bazel.remote.execution.v2.Tree")
	proto.RegisterType((*OutputDirectory)(nil), "build.bazel.remote.execution.v2.OutputDirectory")
	proto.RegisterType((*OutputSymlink)(nil), "build.bazel.remote.execution.v2.OutputSymlink")
	proto.RegisterType((*ExecutionPolicy)(nil), "build.bazel.remote.execution.v2.ExecutionPolicy")
	proto.RegisterType((*ResultsCachePolicy)(nil), "build.bazel.remote.execution.v2.ResultsCachePolicy")
	proto.RegisterType((*ExecuteRequest)(nil), "build.bazel.remote.execution.v2.ExecuteRequest")
	proto.RegisterType((*LogFile)(nil), "build.bazel.remote.execution.v2.LogFile")
	proto.RegisterType((*ExecuteResponse)(nil), "build.bazel.remote.execution.v2.ExecuteResponse")
	proto.RegisterMapType((map[string]*LogFile)(nil), "build.bazel.remote.execution.v2.ExecuteResponse.ServerLogsEntry")
	proto.RegisterType((*ExecutionStage)(nil), "build.bazel.remote.execution.v2.ExecutionStage")
	proto.RegisterType((*ExecuteOperationMetadata)(nil), "build.bazel.remote.execution.v2.ExecuteOperationMetadata")
	proto.RegisterType((*WaitExecutionRequest)(nil), "build.bazel.remote.execution.v2.WaitExecutionRequest")
	proto.RegisterType((*GetActionResultRequest)(nil), "build.bazel.remote.execution.v2.GetActionResultRequest")
	proto.RegisterType((*UpdateActionResultRequest)(nil), "build.bazel.remote.execution.v2.UpdateActionResultRequest")
	proto.RegisterType((*FindMissingBlobsRequest)(nil), "build.bazel.remote.execution.v2.FindMissingBlobsRequest")
	proto.RegisterType((*FindMissingBlobsResponse)(nil), "build.bazel.remote.execution.v2.FindMissingBlobsResponse")
	proto.RegisterType((*BatchUpdateBlobsRequest)(nil), "build.bazel.remote.execution.v2.BatchUpdateBlobsRequest")
	proto.RegisterType((*BatchUpdateBlobsRequest_Request)(nil), "build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request")
	proto.RegisterType((*BatchUpdateBlobsResponse)(nil), "build.bazel.remote.execution.v2.BatchUpdateBlobsResponse")
	proto.RegisterType((*BatchUpdateBlobsResponse_Response)(nil), "build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response")
	proto.RegisterType((*BatchReadBlobsRequest)(nil), "build.bazel.remote.execution.v2.BatchReadBlobsRequest")
	proto.RegisterType((*BatchReadBlobsResponse)(nil), "build.bazel.remote.execution.v2.BatchReadBlobsResponse")
	proto.RegisterType((*BatchReadBlobsResponse_Response)(nil), "build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response")
	proto.RegisterType((*GetTreeRequest)(nil), "build.bazel.remote.execution.v2.GetTreeRequest")
	proto.RegisterType((*GetTreeResponse)(nil), "build.bazel.remote.execution.v2.GetTreeResponse")
	proto.RegisterType((*GetCapabilitiesRequest)(nil), "build.bazel.remote.execution.v2.GetCapabilitiesRequest")
	proto.RegisterType((*ServerCapabilities)(nil), "build.bazel.remote.execution.v2.ServerCapabilities")
	proto.RegisterType((*DigestFunction)(nil), "build.bazel.remote.execution.v2.DigestFunction")
	proto.RegisterType((*ActionCacheUpdateCapabilities)(nil), "build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities")
	proto.RegisterType((*PriorityCapabilities)(nil), "build.bazel.remote.execution.v2.PriorityCapabilities")
	proto.RegisterType((*PriorityCapabilities_PriorityRange)(nil), "build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange")
	proto.RegisterType((*SymlinkAbsolutePathStrategy)(nil), "build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy")
	proto.RegisterType((*Compressor)(nil), "build.bazel.remote.execution.v2.Compressor")
	proto.RegisterType((*CacheCapabilities)(nil), "build.bazel.remote.execution.v2.CacheCapabilities")
	proto.RegisterType((*ExecutionCapabilities)(nil), "build.bazel.remote.execution.v2.ExecutionCapabilities")
	proto.RegisterType((*ToolDetails)(nil), "build.bazel.remote.execution.v2.ToolDetails")
	proto.RegisterType((*RequestMetadata)(nil), "build.bazel.remote.execution.v2.RequestMetadata")
}

func init() {
	proto.RegisterFile("build/bazel/remote/execution/v2/remote_execution.proto", fileDescriptor_c43847ba40caac95)
}

var fileDescriptor_c43847ba40caac95 = []byte{
	// 3546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5b, 0x4d, 0x90, 0x1b, 0x59,
	0x52, 0xde, 0x92, 0xd4, 0xfa, 0x49, 0xa9, 0x25, 0xf5, 0x9b, 0x9e, 0xb6, 0x5a, 0xb6, 0xc7, 0x76,
	0x4d, 0xcc, 0x6e, 0x6f, 0x7b, 0x2c, 0xd9, 0xf2, 0xd8, 0xeb, 0x6d, 0xd8, 0x19, 0xfa, 0x47, 0x1e,
	0xb7, 0xa7, 0xff, 0x28, 0x75, 0xb7, 0x3d, 0xcb, 0xe2, 0xda, 0x6a, 0xd5, 0x6b, 0x75, 0x61, 0xa9,
	0x9e, 0x5c, 0x55, 0xea, 0x1f, 0x4f, 0x38, 0x88, 0x20, 0x62, 0x59, 0x02, 0x22, 0x96, 0x20, 0xe0,
	0x02, 0x7b, 0x21, 0x08, 0x4e, 0x04, 0x47, 0x2e, 0x04, 0x70, 0xe1, 0xb4, 0x04, 0x9c, 0x20, 0x80,
	0x08, 0xce, 0x9c, 0x80, 0x2b, 0x17, 0x82, 0x03, 0xf1, 0x7e, 0xea, 0x4f, 0xaa, 0x76, 0x49, 0xed,
	0x1e, 0xe0, 0xd4, 0x55, 0xf9, 0x5e, 0x7e, 0x99, 0x2f, 0x5f, 0xbe, 0xcc, 0x7c, 0x59, 0x6a, 0x78,
	0x78, 0x30, 0x30, 0xba, 0x7a, 0xfd, 0x40, 0x7b, 0x8d, 0xbb, 0x75, 0x0b, 0xf7, 0x88, 0x83, 0xeb,
	0xf8, 0x14, 0xb7, 0x07, 0x8e, 0x41, 0xcc, 0xfa, 0x71, 0x43, 0xd0, 0x54, 0x8f, 0x56, 0xeb, 0x5b,
	0xc4, 0x21, 0xe8, 0x06, 0xe3, 0xab, 0x31, 0xbe, 0x1a, 0x9f, 0x53, 0xf3, 0xe7, 0x1c, 0x37, 0xaa,
	0x37, 0x82, 0xc0, 0x36, 0xee, 0x1d, 0x63, 0x4b, 0xfc, 0xe1, 0x08, 0xd5, 0x6b, 0x1d, 0x42, 0x3a,
	0x5d, 0x5c, 0xd7, 0xfa, 0x46, 0x5d, 0x33, 0x4d, 0xe2, 0x68, 0x94, 0xd5, 0x16, 0xa3, 0x1f, 0x8a,
	0xd1, 0x2e, 0x31, 0x3b, 0xd6, 0xc0, 0x34, 0x0d, 0xb3, 0x53, 0x27, 0x7d, 0x6c, 0x85, 0x26, 0xcd,
	0x8b, 0x49, 0xec, 0xed, 0x60, 0x70, 0x58, 0xd7, 0xcc, 0x33, 0x31, 0xf4, 0xc1, 0xf0, 0x90, 0x3e,
	0xe0, 0xbc, 0x62, 0xfc, 0xc6, 0xf0, 0xb8, 0x63, 0xf4, 0xb0, 0xed, 0x68, 0xbd, 0xfe, 0x79, 0x00,
	0x27, 0x96, 0xd6, 0xef, 0x63, 0xcb, 0x95, 0x7d, 0x45, 0x8c, 0x5b, 0xfd, 0x76, 0xdd, 0x76, 0x34,
	0x67, 0x20, 0x06, 0xe4, 0x7f, 0x4f, 0x40, 0x7a, 0xb9, 0x4d, 0x45, 0xa1, 0x2d, 0x28, 0xb6, 0x49,
	0xaf, 0xa7, 0x99, 0xba, 0xaa, 0x1b, 0x1d, 0x6c, 0x3b, 0x15, 0xe9, 0xa6, 0xb4, 0x90, 0x6f, 0x7c,
	0xab, 0x16, 0x63, 0xbd, 0xda, 0x1a, 0x9b, 0xae, 0x4c, 0x0b, 0x76, 0xfe, 0x8a, 0x5a, 0x30, 0x63,
	0x98, 0xfd, 0x81, 0xa3, 0x5a, 0x84, 0x38, 0x2e, 0x64, 0x62, 0x32, 0xc8, 0x12, 0x43, 0x50, 0x08,
	0x71, 0x04, 0xe8, 0x7d, 0xc8, 0xd0, 0xb5, 0x93, 0x81, 0x53, 0x49, 0x33, 0xa8, 0xf9, 0x1a, 0x5f,
	0x5a, 0xcd, 0x5d, 0x7a, 0x6d, 0x4d, 0xd8, 0x4e, 0x71, 0x67, 0xa2, 0x9b, 0x50, 0xd0, 0x89, 0x6a,
	0x12, 0x47, 0x6d, 0x6b, 0xed, 0x23, 0x5c, 0xc9, 0xdc, 0x94, 0x16, 0xb2, 0x0a, 0xe8, 0x64, 0x8b,
	0x38, 0xab, 0x94, 0x82, 0x10, 0xa4, 0x6c, 0xad, 0xeb, 0x54, 0x72, 0x37, 0xa5, 0x85, 0x82, 0xc2,
	0x9e, 0x51, 0x13, 0xb2, 0xfd, 0xae, 0xe6, 0x1c, 0x12, 0xab, 0x57, 0x01, 0x26, 0xeb, 0xdb, 0xb1,
	0x6a, 0xef, 0x08, 0x06, 0xc5, 0x63, 0x7d, 0x9a, 0xca, 0x26, 0xcb, 0xe9, 0xa7, 0xa9, 0x6c, 0xb6,
	0x9c, 0x93, 0xff, 0x2b, 0x09, 0x99, 0x55, 0x6e, 0x24, 0x74, 0x0d, 0x72, 0x9a, 0xd5, 0x19, 0xf4,
	0xb0, 0xe9, 0xd8, 0x15, 0xe9, 0x66, 0x72, 0x21, 0xa7, 0xf8, 0x04, 0xf4, 0x0a, 0xde, 0xc7, 0xe6,
	0xb1, 0x61, 0x11, 0x93, 0xbe, 0xab, 0xc7, 0x9a, 0x65, 0x68, 0x07, 0x5d, 0x6c, 0x57, 0x12, 0x37,
	0x93, 0x0b, 0xf9, 0xc6, 0xcf, 0xc7, 0x6a, 0x22, 0xc4, 0xd4, 0x9a, 0x3e, 0xca, 0xbe, 0x00, 0x51,
	0x66, 0xf1, 0x28, 0xd1, 0x46, 0xb7, 0xa0, 0x40, 0x06, 0x0e, 0xdd, 0xb0, 0x43, 0x83, 0x4a, 0x4a,
	0x32, 0x9d, 0xf2, 0x9c, 0xf6, 0x98, 0x92, 0xd0, 0x1d, 0x40, 0x62, 0x8a, 0x6e, 0x58, 0xb8, 0xed,
	0x10, 0xcb, 0xc0, 0x76, 0x25, 0xc5, 0x26, 0xce, 0xf0, 0x91, 0x35, 0x7f, 0x20, 0x80, 0xd8, 0xd7,
	0x9c, 0x23, 0xbb, 0x92, 0x09, 0x22, 0xee, 0x50, 0x52, 0xc8, 0xc8, 0x53, 0x17, 0x36, 0x32, 0xba,
	0x0d, 0x33, 0x27, 0xc4, 0x7a, 0x69, 0x98, 0x1d, 0x4f, 0xb3, 0x33, 0xe6, 0x20, 0x39, 0xa5, 0x2c,
	0x06, 0x5c, 0xc5, 0xce, 0xd0, 0x27, 0x30, 0x27, 0xd4, 0x32, 0x89, 0x8e, 0xd5, 0xbe, 0x45, 0x8f,
	0xaa, 0x43, 0x57, 0x92, 0x65, 0x0a, 0xce, 0xf2, 0xd1, 0x2d, 0xa2, 0xe3, 0x1d, 0x6f, 0xac, 0xfa,
	0x19, 0xbc, 0x17, 0x61, 0x4b, 0xea, 0x39, 0xa6, 0xd6, 0xc3, 0xec, 0xac, 0xe4, 0x14, 0xf6, 0x8c,
	0x66, 0x61, 0xea, 0x58, 0xeb, 0x0e, 0x30, 0xf3, 0xf6, 0x9c, 0xc2, 0x5f, 0xe4, 0xdf, 0x93, 0x20,
	0xeb, 0xaa, 0x8e, 0x14, 0x80, 0x80, 0x5c, 0x89, 0x6d, 0x6a, 0x63, 0xec, 0x95, 0xd7, 0x84, 0x5e,
	0x67, 0x4a, 0x00, 0xa5, 0xfa, 0x09, 0x64, 0x5d, 0xfa, 0x04, 0x6a, 0xfd, 0x2c, 0x01, 0x39, 0xdf,
	0x36, 0x9f, 0xc1, 0x14, 0xdf, 0x7d, 0xae, 0x52, 0xfc, 0x66, 0x50, 0xc7, 0xa0, 0x96, 0x52, 0x38,
	0x1f, 0xda, 0x81, 0x7c, 0xd0, 0x37, 0xb8, 0xbb, 0xd6, 0xc6, 0x38, 0xef, 0x42, 0x03, 0x86, 0x15,
	0x84, 0x40, 0x4f, 0x20, 0x6b, 0x9f, 0xf5, 0xba, 0x86, 0xf9, 0x92, 0xfb, 0x64, 0xbe, 0xf1, 0x71,
	0x2c, 0x5c, 0x8b, 0x33, 0x30, 0x30, 0x8f, 0x1b, 0x3d, 0x87, 0xd2, 0xf0, 0x8e, 0x73, 0x9f, 0xab,
	0xc7, 0x02, 0x86, 0x9d, 0x41, 0x29, 0x9a, 0xa1, 0xf7, 0xa7, 0xa9, 0x6c, 0xaa, 0x3c, 0x25, 0x3f,
	0x82, 0x42, 0x60, 0xde, 0x24, 0x9b, 0xf0, 0x77, 0x12, 0x14, 0xc3, 0x22, 0xd0, 0x66, 0x84, 0x87,
	0xdc, 0x99, 0x44, 0xcf, 0x90, 0x73, 0xa0, 0xbb, 0x30, 0xd5, 0xa3, 0xf1, 0x50, 0x44, 0xe0, 0xea,
	0x48, 0xd8, 0xdc, 0x75, 0x53, 0x8a, 0xc2, 0x27, 0xa2, 0xef, 0x42, 0x6e, 0x60, 0x1a, 0xa7, 0x6a,
	0x8f, 0xe8, 0xb8, 0x92, 0x64, 0x5c, 0xd7, 0x46, 0xb8, 0xf6, 0xd6, 0x4d, 0xe7, 0x7e, 0x63, 0x9f,
	0x2e, 0x42, 0xc9, 0xd2, 0xe9, 0x9b, 0x44, 0xc7, 0xf2, 0xbf, 0x49, 0x90, 0x75, 0x1d, 0x23, 0xd2,
	0x0a, 0x9f, 0x41, 0xfa, 0x62, 0x09, 0x41, 0xb0, 0xa1, 0x0f, 0x61, 0xda, 0xb0, 0x45, 0x9e, 0xa7,
	0xe7, 0xb0, 0x92, 0x62, 0x31, 0xbd, 0x60, 0xd8, 0x4d, 0x8f, 0x16, 0xb5, 0xdf, 0xe9, 0xcb, 0xda,
	0xef, 0x64, 0x39, 0xf5, 0x34, 0x95, 0x9d, 0x2a, 0xa7, 0x65, 0x1d, 0xa6, 0x43, 0xde, 0xfb, 0xb5,
	0x2c, 0x58, 0xfe, 0x7d, 0x09, 0xf2, 0x01, 0xaf, 0x8e, 0x14, 0x32, 0x07, 0x69, 0x47, 0xb3, 0x3a,
	0xd8, 0x11, 0xce, 0x25, 0xde, 0xa2, 0xec, 0x90, 0xba, 0x44, 0x3b, 0xc8, 0x3f, 0x07, 0x69, 0x91,
	0x9e, 0x11, 0xa4, 0x8e, 0x34, 0xfb, 0xc8, 0xd5, 0x8a, 0x3e, 0xa3, 0xeb, 0x00, 0xb6, 0xf1, 0x1a,
	0xab, 0x07, 0x67, 0x0e, 0x0b, 0x08, 0xd2, 0x42, 0x52, 0xc9, 0x51, 0xca, 0x0a, 0x25, 0xc8, 0x7f,
	0x9c, 0x81, 0x39, 0xbe, 0x67, 0x58, 0xe7, 0x95, 0xc8, 0x26, 0x76, 0x34, 0x5d, 0x73, 0x34, 0xba,
	0x1e, 0x1a, 0xbc, 0xb1, 0x25, 0xf0, 0xc4, 0x1b, 0x6a, 0x42, 0xf9, 0xd5, 0x00, 0x0f, 0xb0, 0xae,
	0x7a, 0x75, 0xd0, 0x18, 0x6e, 0x5d, 0xe2, 0x3c, 0x1e, 0x01, 0xed, 0xc0, 0x1c, 0x07, 0x54, 0x6d,
	0x47, 0xb3, 0x9c, 0x00, 0x58, 0x32, 0x16, 0x6c, 0x96, 0x73, 0xb6, 0x28, 0xa3, 0x8f, 0xf8, 0x1c,
	0xaa, 0x02, 0xb1, 0x4d, 0x7a, 0xfd, 0x2e, 0x76, 0x42, 0x2a, 0xa6, 0x62, 0x51, 0x2b, 0x9c, 0x7b,
	0xd5, 0x65, 0xf6, 0x91, 0xbf, 0x84, 0xab, 0xbc, 0x98, 0x3a, 0xc4, 0x4e, 0xfb, 0x68, 0x44, 0xe1,
	0xa9, 0x78, 0x68, 0xc6, 0xfe, 0x98, 0x72, 0x0f, 0x29, 0xad, 0xc1, 0x8d, 0x20, 0x74, 0x94, 0xe6,
	0xe9, 0x58, 0xf8, 0x6b, 0x3e, 0x7c, 0x84, 0xf6, 0xfb, 0x30, 0xef, 0x79, 0xd5, 0x88, 0xee, 0x99,
	0x58, 0xf0, 0x2b, 0x1e, 0xf3, 0x90, 0xea, 0x2f, 0xe0, 0xba, 0x8f, 0x1b, 0xa5, 0x78, 0x36, 0x16,
	0xfb, 0xaa, 0x07, 0x10, 0xa1, 0xf7, 0x2f, 0xc3, 0x75, 0x51, 0x29, 0x0c, 0xfa, 0x5d, 0xa2, 0xe9,
	0x23, 0xba, 0xe7, 0x62, 0xf1, 0xab, 0x1c, 0x60, 0x8f, 0xf1, 0x0f, 0xa9, 0x8f, 0xe1, 0x56, 0x18,
	0x3e, 0x6a, 0x09, 0x10, 0x2b, 0xe2, 0x83, 0xa0, 0x88, 0x88, 0x55, 0xac, 0x02, 0xd2, 0x06, 0xa7,
	0x46, 0xd7, 0xd0, 0xac, 0x33, 0xb5, 0x27, 0x0e, 0x57, 0x25, 0xcf, 0x32, 0xca, 0xec, 0x08, 0xee,
	0xb2, 0x79, 0xa6, 0xcc, 0x78, 0xf3, 0xdd, 0xb3, 0x28, 0xff, 0x6d, 0x1a, 0x0a, 0xfc, 0x78, 0x2a,
	0xd8, 0x1e, 0x74, 0x1d, 0xb4, 0x35, 0x54, 0x2e, 0xf2, 0x4c, 0x7f, 0x3b, 0x36, 0xa2, 0x6c, 0x7b,
	0xf5, 0x64, 0xb8, 0xb6, 0xfc, 0x21, 0xcc, 0x06, 0xf0, 0x54, 0x2f, 0xe5, 0xc3, 0x98, 0x15, 0x04,
	0xc7, 0x15, 0x21, 0x52, 0x41, 0x3e, 0x74, 0xcb, 0x4d, 0xff, 0xcf, 0xa0, 0x24, 0x24, 0x78, 0xe0,
	0x85, 0x0b, 0x81, 0x17, 0x49, 0xf0, 0xd5, 0x46, 0x6a, 0x64, 0x59, 0xcc, 0x6b, 0x95, 0xbb, 0x63,
	0x62, 0x7b, 0x29, 0x24, 0xaa, 0x90, 0xfe, 0x15, 0x98, 0x1f, 0x12, 0x70, 0xe6, 0xaf, 0x21, 0x7f,
	0xa1, 0x35, 0x5c, 0x09, 0x4b, 0x39, 0xf3, 0x16, 0x73, 0x15, 0x72, 0xf8, 0xd4, 0x70, 0xd4, 0x36,
	0x4d, 0xfb, 0x34, 0x64, 0x4d, 0x29, 0x59, 0x4a, 0x58, 0xa5, 0x59, 0x87, 0xc6, 0x72, 0x47, 0x27,
	0xf4, 0x52, 0xa7, 0x9d, 0xb0, 0xa8, 0x53, 0x50, 0x72, 0x9c, 0xa2, 0x68, 0x27, 0x68, 0x03, 0xa6,
	0xc5, 0xb0, 0x48, 0x76, 0xe9, 0xc9, 0x92, 0x5d, 0x81, 0x73, 0x8b, 0x64, 0xc2, 0x85, 0x61, 0xcb,
	0x62, 0xc2, 0x32, 0x9e, 0x30, 0x6c, 0x59, 0xbe, 0x30, 0x3a, 0x2c, 0x84, 0x65, 0x27, 0x17, 0x86,
	0x2d, 0x4b, 0x08, 0x3b, 0x04, 0xe4, 0x87, 0x12, 0xef, 0x90, 0xf0, 0xf3, 0xfd, 0x9d, 0x58, 0xc8,
	0xe8, 0x04, 0xa6, 0xcc, 0x78, 0x93, 0x5c, 0xd2, 0xd3, 0x54, 0x56, 0x2a, 0x27, 0xe4, 0xdf, 0x48,
	0x00, 0xf8, 0x07, 0x81, 0xa6, 0x4d, 0x7a, 0x43, 0x72, 0xd3, 0x26, 0x7d, 0xfe, 0x5f, 0x2a, 0x91,
	0xaa, 0x90, 0x6d, 0x13, 0xd3, 0x61, 0x97, 0x50, 0xbe, 0x9d, 0xde, 0x7b, 0x54, 0xd9, 0x90, 0xb9,
	0xdc, 0xf2, 0x29, 0x5d, 0xce, 0xc8, 0x3f, 0x91, 0x20, 0xb5, 0x6b, 0x61, 0x8c, 0x3e, 0x85, 0x94,
	0x45, 0x88, 0xdb, 0x75, 0x58, 0x1c, 0xff, 0xca, 0xa0, 0x30, 0x3e, 0xf4, 0x18, 0xb2, 0xed, 0x23,
	0xa3, 0xab, 0x5b, 0xd8, 0x14, 0xc1, 0x68, 0x12, 0x0c, 0x8f, 0x57, 0x1e, 0x40, 0x69, 0xe8, 0x48,
	0x46, 0xee, 0xcf, 0x13, 0xc8, 0x3b, 0x16, 0xc6, 0xae, 0xf3, 0x25, 0x27, 0xdb, 0x24, 0xa0, 0xbc,
	0xfc, 0xf9, 0x69, 0x2a, 0x9b, 0x28, 0x27, 0xe5, 0x9f, 0x4a, 0x30, 0x1d, 0x3a, 0xa2, 0x91, 0x52,
	0xff, 0xaf, 0x4a, 0xbc, 0x3b, 0x50, 0x6a, 0xba, 0x4c, 0x3b, 0xa4, 0x6b, 0xb4, 0xcf, 0xa8, 0xeb,
	0xf4, 0x2d, 0x83, 0x58, 0x86, 0x73, 0xc6, 0x54, 0x9c, 0x52, 0xbc, 0x77, 0xf9, 0x2e, 0x20, 0x9e,
	0x26, 0x6c, 0xd6, 0x5f, 0x19, 0x83, 0xe3, 0x47, 0x49, 0x28, 0x8a, 0x53, 0xa4, 0xe0, 0x57, 0x03,
	0xd7, 0x81, 0x4d, 0xdb, 0xd1, 0xcc, 0x36, 0x56, 0x03, 0xb5, 0x6e, 0xc1, 0x25, 0x6e, 0xd1, 0x9a,
	0x77, 0x11, 0x66, 0xec, 0x97, 0x46, 0x9f, 0x77, 0x76, 0xd4, 0x2e, 0x21, 0x2f, 0x07, 0xbc, 0x7e,
	0xcb, 0x2a, 0x25, 0x3a, 0xc0, 0xe4, 0x6f, 0x30, 0x32, 0x8d, 0x18, 0x1a, 0x3b, 0xa0, 0x17, 0x0d,
	0x4f, 0x9c, 0x5b, 0x44, 0x8c, 0x5f, 0x82, 0xb2, 0x1f, 0x31, 0xfa, 0x6c, 0x85, 0xe2, 0x7c, 0xdc,
	0x1d, 0x33, 0x5e, 0x78, 0xb6, 0x54, 0x4a, 0x78, 0xc8, 0xb8, 0x18, 0x66, 0x2d, 0x6e, 0x40, 0xb1,
	0x32, 0x21, 0x80, 0xc7, 0xb8, 0xfb, 0xb1, 0x02, 0x46, 0xad, 0xaf, 0x20, 0x6b, 0x84, 0xc6, 0x5d,
	0x8f, 0xdf, 0x5e, 0xc5, 0x6d, 0xe6, 0x15, 0x64, 0x36, 0x48, 0x87, 0x45, 0x25, 0x3f, 0x02, 0x49,
	0x17, 0x8b, 0x40, 0x1f, 0x41, 0xf1, 0x68, 0xd0, 0xd3, 0x4c, 0xd5, 0xc2, 0x9a, 0xce, 0x42, 0x50,
	0x82, 0x6d, 0xcc, 0x34, 0xa3, 0x2a, 0x82, 0x28, 0xff, 0x76, 0xd2, 0x75, 0x2e, 0xac, 0x60, 0xbb,
	0x4f, 0x4c, 0x1b, 0xa3, 0x26, 0xa4, 0xb9, 0xba, 0x42, 0x76, 0xfc, 0xcd, 0x37, 0x58, 0x9c, 0x28,
	0x82, 0x99, 0xba, 0x10, 0x33, 0x9f, 0xae, 0x0a, 0x34, 0xae, 0x40, 0x81, 0x13, 0x45, 0x25, 0xb3,
	0x08, 0x69, 0xde, 0x13, 0x15, 0x87, 0x18, 0xb9, 0x35, 0x91, 0xd5, 0x6f, 0xd7, 0x5a, 0x6c, 0x44,
	0x11, 0x33, 0x90, 0x06, 0x79, 0x1b, 0x5b, 0xc7, 0xd8, 0x52, 0xbb, 0xa4, 0xc3, 0x5b, 0x5f, 0xf9,
	0xc6, 0x2f, 0x8c, 0x9b, 0x1f, 0xdc, 0xe5, 0xd5, 0x5a, 0x0c, 0x63, 0x83, 0x74, 0xec, 0xa6, 0xe9,
	0x58, 0x67, 0x0a, 0xd8, 0x1e, 0x01, 0x55, 0x20, 0xd3, 0xc3, 0xb6, 0xad, 0x75, 0x30, 0x8b, 0xc8,
	0x39, 0xc5, 0x7d, 0xad, 0x76, 0xa0, 0x34, 0xc4, 0x88, 0xca, 0x90, 0x7c, 0x89, 0xcf, 0xc4, 0xc9,
	0xa0, 0x8f, 0xe8, 0xd3, 0x60, 0x83, 0x21, 0xdf, 0x58, 0x88, 0xd5, 0x4d, 0x6c, 0xb7, 0x68, 0x45,
	0x2c, 0x25, 0x1e, 0x49, 0xb2, 0xe6, 0x9e, 0x45, 0x5e, 0x72, 0x77, 0xb0, 0xbc, 0x0d, 0x53, 0xec,
	0x92, 0x8f, 0xf2, 0x90, 0xd9, 0xdb, 0xfa, 0x62, 0x6b, 0xfb, 0xd9, 0x56, 0xf9, 0x1b, 0xa8, 0x04,
	0xf9, 0xd5, 0xe5, 0xd5, 0x27, 0x4d, 0x75, 0xf5, 0x49, 0x73, 0xf5, 0x8b, 0xb2, 0x84, 0x00, 0xd2,
	0xbf, 0xb8, 0xd7, 0xdc, 0x6b, 0xae, 0x95, 0x13, 0x68, 0x1a, 0x72, 0xcd, 0xe7, 0xcd, 0xd5, 0xbd,
	0xdd, 0xf5, 0xad, 0xcf, 0xcb, 0x49, 0xfa, 0xba, 0xba, 0xbd, 0xb9, 0xb3, 0xd1, 0xdc, 0x6d, 0xae,
	0x95, 0x53, 0xf2, 0xef, 0x24, 0xa0, 0x22, 0xac, 0xb2, 0xed, 0x76, 0xca, 0xbd, 0x8b, 0xdf, 0x17,
	0x30, 0x65, 0x53, 0xb1, 0x6c, 0x5d, 0xc5, 0xc6, 0x83, 0xf1, 0xcf, 0x13, 0xd3, 0xb6, 0xc6, 0xfb,
	0x11, 0x1c, 0x63, 0xf4, 0xd4, 0x27, 0xde, 0xe5, 0xd4, 0x7f, 0x0c, 0x48, 0x94, 0x38, 0xb6, 0x63,
	0x61, 0xad, 0xc7, 0x23, 0x53, 0x92, 0xb7, 0x1a, 0xf9, 0x48, 0x8b, 0x0d, 0xb0, 0xe8, 0xc4, 0x67,
	0xd3, 0x1a, 0x25, 0x38, 0x3b, 0xe5, 0xcd, 0xc6, 0x96, 0xe5, 0xcf, 0x96, 0x17, 0x61, 0xf6, 0x99,
	0x66, 0x38, 0xde, 0x62, 0xdc, 0x40, 0x18, 0x71, 0xd7, 0x97, 0x7f, 0x94, 0x80, 0xb9, 0xcf, 0xb1,
	0x13, 0xf2, 0xfa, 0x49, 0xe2, 0xe6, 0xe5, 0x5a, 0x85, 0x89, 0xec, 0x1a, 0x26, 0x56, 0xb9, 0x09,
	0x44, 0x04, 0x2e, 0x70, 0x62, 0x8b, 0xd1, 0xc2, 0x93, 0xb0, 0x65, 0x79, 0x05, 0x89, 0x3b, 0x09,
	0x5b, 0x16, 0xaa, 0xc1, 0x7b, 0x62, 0x52, 0xe8, 0x76, 0x31, 0xc5, 0x7b, 0xcc, 0x7c, 0xc8, 0xaf,
	0x9c, 0x6c, 0xf9, 0x6f, 0x12, 0x30, 0xbf, 0xd7, 0xd7, 0x35, 0x07, 0xff, 0x3f, 0x31, 0x85, 0xe2,
	0xa1, 0x89, 0x90, 0x93, 0xbc, 0x48, 0x00, 0x13, 0x98, 0x22, 0x42, 0x9d, 0x97, 0x0d, 0x52, 0x97,
	0x9a, 0x0d, 0xe4, 0xdf, 0x94, 0xe0, 0xca, 0x63, 0xc3, 0xd4, 0x37, 0x0d, 0xdb, 0x36, 0xcc, 0xce,
	0x4a, 0x97, 0x1c, 0xd8, 0x13, 0x59, 0xf2, 0x29, 0x14, 0x0e, 0xba, 0xe4, 0x40, 0xd8, 0xd1, 0xbd,
	0x13, 0x8e, 0x6d, 0xc8, 0x3c, 0x65, 0xe6, 0xcf, 0xb6, 0x3c, 0x80, 0xca, 0xa8, 0x2e, 0x22, 0x3b,
	0x7c, 0x09, 0xb3, 0x3d, 0x4e, 0x57, 0xdf, 0x45, 0x1e, 0xea, 0xf9, 0xe0, 0xae, 0xd8, 0xff, 0x96,
	0xe0, 0xca, 0x8a, 0xe6, 0xb4, 0x8f, 0xb8, 0x53, 0x4d, 0x6e, 0x83, 0x1f, 0x40, 0xd6, 0xe2, 0xf3,
	0x5d, 0x7d, 0xe2, 0xd3, 0xc3, 0x39, 0x02, 0x6b, 0xe2, 0xaf, 0xe2, 0x21, 0x56, 0x5f, 0x40, 0xc6,
	0xd5, 0xe6, 0x9d, 0xd3, 0x33, 0x82, 0x14, 0xbb, 0xe4, 0x24, 0xf8, 0x47, 0x2f, 0x76, 0xcd, 0xff,
	0x4f, 0x09, 0x2a, 0xa3, 0xda, 0x08, 0xb3, 0xff, 0x10, 0x72, 0x96, 0x78, 0x76, 0x3b, 0xd2, 0x2b,
	0x17, 0x58, 0x9b, 0xc8, 0x81, 0xee, 0x83, 0xe2, 0x83, 0x56, 0x4f, 0x20, 0xeb, 0x49, 0x7b, 0xe7,
	0xf5, 0xf9, 0x79, 0x3d, 0x11, 0x97, 0xd7, 0xe5, 0x5f, 0x85, 0xf7, 0x99, 0xa2, 0xb4, 0x28, 0x99,
	0x7c, 0xcf, 0x97, 0x21, 0x73, 0x41, 0x17, 0x74, 0xf9, 0xe4, 0x5f, 0x4f, 0xc0, 0xdc, 0xb0, 0x06,
	0xc2, 0x10, 0x2f, 0x46, 0xcd, 0x3e, 0xa6, 0x4b, 0x8d, 0x60, 0x45, 0x1a, 0xfd, 0xb7, 0xa4, 0xcb,
	0xb4, 0x7a, 0x84, 0x57, 0x4d, 0x52, 0x61, 0xc9, 0x7f, 0x21, 0x41, 0xf1, 0x73, 0xec, 0xd0, 0x2b,
	0xe1, 0x44, 0x7b, 0xf0, 0x04, 0xf2, 0xef, 0xf0, 0xa1, 0x19, 0x2c, 0xff, 0x1b, 0xf3, 0x55, 0xc8,
	0xf5, 0xb5, 0x0e, 0x56, 0x6d, 0xe3, 0x35, 0xcf, 0xec, 0xf4, 0x9e, 0xa2, 0x75, 0x70, 0xcb, 0x78,
	0xcd, 0x3a, 0x20, 0x6c, 0xd0, 0x21, 0x2f, 0xb1, 0x29, 0x32, 0x39, 0x9b, 0xbe, 0x4b, 0x09, 0xf2,
	0x8f, 0x25, 0x28, 0x79, 0xda, 0x0b, 0x93, 0x6e, 0x84, 0x3f, 0x89, 0x49, 0x13, 0xdf, 0x4d, 0x43,
	0x9f, 0xc3, 0xbe, 0x09, 0x25, 0x13, 0x9f, 0x3a, 0x6a, 0x40, 0x0b, 0x7e, 0x15, 0x9c, 0xa6, 0xe4,
	0x1d, 0x4f, 0x93, 0xef, 0xb1, 0xfa, 0x60, 0x55, 0xeb, 0x6b, 0x07, 0x46, 0xd7, 0x60, 0x57, 0xbb,
	0x09, 0xcc, 0x29, 0xff, 0x75, 0x12, 0x10, 0x2f, 0x36, 0x83, 0x10, 0x48, 0x03, 0xc4, 0x33, 0x50,
	0x3b, 0x40, 0x15, 0xae, 0x12, 0xff, 0xfd, 0x92, 0x25, 0x9b, 0x90, 0x4a, 0x33, 0xed, 0x61, 0x12,
	0xea, 0xc1, 0x5c, 0xa0, 0xa9, 0x1b, 0x14, 0xc3, 0xf7, 0xf4, 0xe1, 0xf8, 0xd5, 0x60, 0x48, 0xd4,
	0xfb, 0x38, 0x8a, 0x8c, 0x76, 0x60, 0x4e, 0xc7, 0x7d, 0x0b, 0xb7, 0x35, 0x07, 0xeb, 0xaa, 0xd6,
	0x37, 0xd4, 0x63, 0x6c, 0xd9, 0x06, 0x31, 0xbd, 0xaf, 0x00, 0x41, 0x71, 0xe2, 0x47, 0x21, 0x2d,
	0xdc, 0xdb, 0xc7, 0x96, 0x32, 0xeb, 0x73, 0x2e, 0xf7, 0x8d, 0x7d, 0xce, 0x87, 0x56, 0xa0, 0xd4,
	0x25, 0x27, 0x21, 0xa8, 0x54, 0x2c, 0xd4, 0x74, 0x97, 0x9c, 0x04, 0x30, 0xd6, 0xa0, 0x7c, 0x64,
	0x74, 0x8e, 0x42, 0x20, 0x53, 0xb1, 0x20, 0x45, 0xca, 0xe3, 0xa3, 0xc8, 0x36, 0x14, 0xb9, 0x4f,
	0x3f, 0x1e, 0x98, 0xac, 0x9e, 0x90, 0xb5, 0xc8, 0x3a, 0x1e, 0x20, 0xdd, 0x7a, 0xb2, 0xdc, 0x78,
	0xf0, 0xb0, 0x2c, 0xa1, 0x2c, 0xa4, 0x5a, 0x4f, 0x96, 0xef, 0x95, 0x13, 0x28, 0x03, 0xc9, 0xcd,
	0xb5, 0x07, 0xe5, 0x24, 0x7d, 0xd8, 0x6f, 0x6d, 0x97, 0x53, 0x62, 0xde, 0xfd, 0x47, 0x9f, 0x94,
	0xa7, 0xc4, 0xf3, 0x83, 0x7b, 0x8d, 0x72, 0x9a, 0x82, 0x6d, 0xee, 0x29, 0x9b, 0x7b, 0xca, 0xfd,
	0x72, 0x46, 0x7e, 0x0c, 0xd7, 0x79, 0x29, 0xc3, 0x76, 0x9b, 0x47, 0xfe, 0x90, 0xc5, 0x3f, 0x82,
	0xe2, 0x80, 0x51, 0x55, 0x6c, 0xd2, 0x0b, 0xa0, 0xce, 0xfc, 0x27, 0xab, 0x4c, 0x73, 0x6a, 0x93,
	0x13, 0xe5, 0xbf, 0x97, 0x60, 0x76, 0x47, 0xb4, 0x07, 0x42, 0xfc, 0x6d, 0x00, 0xd1, 0x36, 0xf0,
	0x8f, 0xd3, 0x6a, 0xfc, 0xb7, 0xf3, 0x08, 0x28, 0x8f, 0xa8, 0x68, 0x66, 0x07, 0x2b, 0x01, 0xd8,
	0xea, 0x1e, 0x4c, 0x87, 0x06, 0xd1, 0x2d, 0x28, 0xf4, 0x0c, 0x53, 0x1d, 0x6a, 0x60, 0xe4, 0x7b,
	0x86, 0xe9, 0xce, 0x63, 0x53, 0xb4, 0x53, 0x7f, 0x4a, 0x42, 0x4c, 0xd1, 0x4e, 0xdd, 0x29, 0xf2,
	0x0e, 0x5c, 0x15, 0xed, 0x9d, 0xe5, 0x03, 0x9b, 0x74, 0x07, 0x0e, 0xde, 0xd1, 0x9c, 0xa3, 0x96,
	0x63, 0x69, 0x0e, 0xee, 0x9c, 0xc9, 0xf7, 0x22, 0xb7, 0xa7, 0x08, 0xb0, 0xb6, 0xde, 0x5a, 0xde,
	0xd8, 0xd8, 0x7e, 0xd6, 0x5c, 0x2b, 0x4b, 0x74, 0xd0, 0x7d, 0x49, 0xc8, 0x77, 0x00, 0x56, 0x49,
	0xaf, 0x6f, 0x61, 0xdb, 0x26, 0x96, 0x7c, 0xc3, 0x05, 0x28, 0x40, 0x76, 0x7d, 0xad, 0xb9, 0xb5,
	0xbb, 0xbe, 0xfb, 0x65, 0xf9, 0x1b, 0x74, 0x53, 0xbf, 0xdf, 0xda, 0x5d, 0x2b, 0x4b, 0xf2, 0x1f,
	0x4e, 0xc1, 0xcc, 0xc8, 0x31, 0x44, 0x2f, 0xa0, 0xc4, 0xe3, 0xa6, 0x7a, 0x28, 0x3c, 0x85, 0xd9,
	0x75, 0x9c, 0xab, 0x57, 0xd8, 0xc1, 0xc4, 0xd5, 0xab, 0xa8, 0x87, 0xa8, 0xe8, 0xc7, 0x12, 0xdc,
	0x14, 0x55, 0x31, 0x0f, 0x1f, 0xc2, 0x01, 0x22, 0x8e, 0xf7, 0xa7, 0x63, 0x16, 0xca, 0xe7, 0x78,
	0x97, 0x72, 0x5d, 0x7b, 0xab, 0xf3, 0x0d, 0xe0, 0xaa, 0x28, 0xa1, 0xc5, 0x96, 0x84, 0x75, 0xe0,
	0x67, 0xfe, 0xc1, 0x85, 0xbc, 0x49, 0x99, 0x67, 0xc8, 0x91, 0x3e, 0xbb, 0x04, 0x55, 0xea, 0x1a,
	0x07, 0x34, 0x2b, 0xab, 0x0e, 0x71, 0xb4, 0xae, 0x1a, 0xf8, 0x28, 0x9a, 0x62, 0x1f, 0x45, 0xe7,
	0x7a, 0xda, 0x29, 0x4b, 0xdb, 0xbb, 0x74, 0xbc, 0xe5, 0x7e, 0x21, 0xa5, 0xc6, 0xfb, 0x40, 0x74,
	0xfb, 0x55, 0x4d, 0x78, 0x0d, 0xfb, 0x45, 0x0d, 0xbd, 0x54, 0x32, 0xbf, 0x61, 0xa1, 0xa1, 0x38,
	0x46, 0x31, 0xf6, 0x16, 0xdf, 0x13, 0x3b, 0x77, 0xd5, 0x3e, 0x7f, 0x0a, 0xd2, 0x61, 0xd6, 0x1e,
	0xf4, 0xfb, 0xc4, 0xa2, 0xa1, 0xb2, 0xed, 0x79, 0x5d, 0x25, 0xcd, 0x7c, 0xe5, 0xde, 0x38, 0x3f,
	0x4a, 0x12, 0x2c, 0x42, 0xda, 0x7b, 0x1e, 0x5c, 0xc0, 0x87, 0xff, 0x31, 0x01, 0xef, 0x47, 0x86,
	0xf0, 0x68, 0x37, 0x95, 0x2e, 0xcf, 0x4d, 0x6f, 0x41, 0x81, 0x32, 0x79, 0x71, 0x89, 0x77, 0x8b,
	0xf2, 0x94, 0x26, 0xa2, 0x12, 0x7a, 0x03, 0x37, 0x02, 0x5d, 0xbf, 0xcb, 0xf7, 0x21, 0xff, 0x83,
	0xe6, 0x39, 0x7e, 0x34, 0xef, 0xef, 0xc0, 0x68, 0xc7, 0x97, 0x5e, 0x92, 0xaf, 0x78, 0x13, 0xc2,
	0x9d, 0x5d, 0x79, 0x13, 0xf2, 0xbb, 0x84, 0x74, 0xd7, 0xb0, 0xa3, 0x19, 0x5d, 0xf6, 0xa1, 0xc7,
	0x21, 0xa4, 0x1b, 0x2c, 0x01, 0xb2, 0x94, 0xc0, 0xaa, 0xa9, 0x5b, 0x50, 0x60, 0x83, 0x6e, 0xee,
	0xe1, 0x25, 0x46, 0x9e, 0xd2, 0xdc, 0xe4, 0xf2, 0x2f, 0x09, 0x28, 0x89, 0x92, 0xc2, 0x6b, 0xdc,
	0x6c, 0x0b, 0x36, 0x9d, 0xcb, 0x10, 0x85, 0x41, 0xfc, 0xef, 0x75, 0x02, 0x7a, 0x71, 0x21, 0x01,
	0x25, 0x45, 0xdc, 0x30, 0x74, 0xa1, 0x44, 0x96, 0x13, 0xd6, 0x75, 0xf4, 0x31, 0x20, 0x26, 0xcd,
	0x30, 0x8f, 0x49, 0x5b, 0x73, 0x67, 0x89, 0x5e, 0x0c, 0x1d, 0x59, 0xf7, 0x06, 0xd6, 0x75, 0x6a,
	0xba, 0x36, 0xb1, 0x2c, 0xdc, 0x65, 0x89, 0xde, 0xe7, 0xb1, 0x29, 0x13, 0x2f, 0xe4, 0xae, 0xf8,
	0x13, 0x7c, 0x56, 0x7b, 0x5d, 0x47, 0xdf, 0x82, 0x92, 0x50, 0xa3, 0x67, 0xe2, 0x1e, 0x31, 0x8d,
	0xb6, 0xe8, 0xcd, 0x15, 0x39, 0x79, 0x53, 0x50, 0x99, 0x51, 0x59, 0x47, 0x9e, 0x82, 0xa6, 0x85,
	0x51, 0x19, 0x61, 0x5d, 0x47, 0xdf, 0x86, 0x72, 0x9b, 0x98, 0x87, 0x46, 0x47, 0xfc, 0x42, 0x91,
	0xce, 0xc9, 0xb0, 0x39, 0xa5, 0x10, 0x7d, 0x5d, 0x6f, 0xfc, 0x79, 0x02, 0x72, 0xde, 0x19, 0x40,
	0x3f, 0x91, 0x20, 0x23, 0x9a, 0x65, 0xa8, 0x3e, 0x7e, 0xb3, 0x91, 0xed, 0x4d, 0xf5, 0xba, 0x5b,
	0x6c, 0x07, 0x7e, 0x9d, 0x5a, 0xf3, 0x7a, 0x6e, 0xf2, 0xbd, 0x5f, 0xfb, 0x87, 0x7f, 0xfd, 0xdd,
	0xc4, 0x6d, 0xf9, 0x9b, 0xf5, 0xe3, 0x46, 0xfd, 0xab, 0x50, 0x61, 0xf8, 0xbd, 0xc5, 0xc5, 0x37,
	0x75, 0xbe, 0x40, 0x7b, 0x89, 0x8b, 0xc0, 0x4b, 0xd2, 0xe2, 0x5d, 0x09, 0xfd, 0x81, 0x04, 0xd3,
	0xa1, 0x56, 0x15, 0x8a, 0x77, 0xf7, 0xa8, 0xd6, 0xd6, 0x64, 0xca, 0x31, 0x9d, 0xfc, 0xdf, 0xd5,
	0xd6, 0x17, 0x17, 0xdf, 0x2c, 0x9d, 0x04, 0x51, 0x99, 0x72, 0x8d, 0x7f, 0x4a, 0x42, 0x3e, 0x90,
	0x23, 0xd0, 0x3f, 0xf3, 0x9a, 0x3c, 0xf4, 0xf5, 0x3a, 0xfe, 0x93, 0x5e, 0x74, 0x73, 0xad, 0x3a,
	0x59, 0x1f, 0x47, 0xfe, 0x01, 0x5b, 0xc0, 0x3e, 0xda, 0x7d, 0xab, 0x75, 0x45, 0x7f, 0xa6, 0xfe,
	0x55, 0xa8, 0x0f, 0x55, 0x3b, 0xd2, 0xec, 0xa3, 0x37, 0xc3, 0x44, 0x3f, 0x6d, 0xbc, 0x41, 0xff,
	0x21, 0x01, 0x1a, 0x6d, 0x7e, 0xa1, 0xa5, 0x58, 0x1d, 0xcf, 0xed, 0x98, 0x4d, 0xba, 0xbe, 0x97,
	0x6c, 0x7d, 0xb8, 0xfa, 0xb5, 0xac, 0x6f, 0x29, 0xdc, 0x49, 0x6b, 0xfc, 0x34, 0x0d, 0xf3, 0xab,
	0xfc, 0xeb, 0xe4, 0xb2, 0xae, 0xd3, 0x6c, 0x41, 0x63, 0x72, 0xcb, 0x21, 0x96, 0xd6, 0xc1, 0xe8,
	0x2f, 0x25, 0x28, 0x0f, 0x77, 0x8c, 0xd0, 0xa3, 0x31, 0x7e, 0xc0, 0x18, 0xd9, 0xf0, 0xaa, 0x7e,
	0xf7, 0x02, 0x9c, 0xfc, 0xc2, 0x27, 0xdf, 0x67, 0x46, 0xb9, 0x23, 0x2f, 0x9c, 0x63, 0x94, 0x03,
	0x3a, 0x7b, 0xe9, 0xd0, 0x67, 0x5f, 0x92, 0x16, 0x99, 0xfa, 0xc3, 0xbd, 0x92, 0x31, 0xd4, 0x3f,
	0xa7, 0x75, 0x34, 0x86, 0xfa, 0xe7, 0x35, 0x66, 0xc6, 0x54, 0xff, 0xc0, 0x67, 0xa7, 0xea, 0xff,
	0x99, 0x04, 0xc5, 0x70, 0xcf, 0x01, 0x3d, 0x9c, 0xb8, 0x49, 0xc1, 0x55, 0xff, 0xce, 0x05, 0x9b,
	0x1b, 0xb1, 0xa1, 0x2c, 0xa0, 0x38, 0x65, 0xa6, 0x6a, 0xff, 0x4c, 0x82, 0x8c, 0xb8, 0xaf, 0x8f,
	0x11, 0x59, 0xc3, 0x7d, 0x89, 0xea, 0xdd, 0xf1, 0x19, 0x84, 0x86, 0xcf, 0x99, 0x86, 0x0a, 0xda,
	0x79, 0x9b, 0x86, 0xf5, 0xaf, 0x02, 0x8d, 0x0c, 0xf7, 0x90, 0x04, 0x49, 0xc1, 0x23, 0xd2, 0xe1,
	0x12, 0xee, 0x4a, 0x8d, 0xbf, 0x92, 0xa0, 0x10, 0xaa, 0x15, 0xfe, 0x94, 0xc7, 0xbd, 0x10, 0x6d,
	0xac, 0xb8, 0x17, 0xd1, 0x34, 0xa8, 0xc6, 0x37, 0x99, 0x47, 0xbb, 0x05, 0xf2, 0x6d, 0xb6, 0xdc,
	0x8f, 0xd0, 0x87, 0xe7, 0x2c, 0x37, 0x58, 0x36, 0xad, 0x58, 0x10, 0xf7, 0x6f, 0x1a, 0x2b, 0xb3,
	0x0a, 0x23, 0xfa, 0x5f, 0x4f, 0x2d, 0xe2, 0x90, 0x1d, 0xe9, 0xfb, 0x25, 0x3e, 0xd9, 0x9b, 0xfb,
	0x47, 0x89, 0xa4, 0xd2, 0x7c, 0xfe, 0x27, 0x89, 0x1b, 0x2b, 0x0c, 0x70, 0x85, 0x01, 0x72, 0x5e,
	0xbf, 0x39, 0x50, 0xdb, 0x6f, 0x1c, 0xa4, 0xd9, 0xcf, 0x9e, 0xee, 0xff, 0x4f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xee, 0x17, 0xa1, 0x7e, 0x59, 0x32, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExecutionClient is the client API for Execution service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExecutionClient interface {
	// Execute an action remotely.
	//
	// In order to execute an action, the client must first upload all of the
	// inputs, the
	// [Command][build.bazel.remote.execution.v2.Command] to run, and the
	// [Action][build.bazel.remote.execution.v2.Action] into the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	// It then calls `Execute` with an `action_digest` referring to them. The
	// server will run the action and eventually return the result.
	//
	// The input `Action`'s fields MUST meet the various canonicalization
	// requirements specified in the documentation for their types so that it has
	// the same digest as other logically equivalent `Action`s. The server MAY
	// enforce the requirements and return errors if a non-canonical input is
	// received. It MAY also proceed without verifying some or all of the
	// requirements, such as for performance reasons. If the server does not
	// verify the requirement, then it will treat the `Action` as distinct from
	// another logically equivalent action if they hash differently.
	//
	// Returns a stream of
	// [google.longrunning.Operation][google.longrunning.Operation] messages
	// describing the resulting execution, with eventual `response`
	// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
	// `metadata` on the operation is of type
	// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
	//
	// If the client remains connected after the first response is returned after
	// the server, then updates are streamed as if the client had called
	// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
	// until the execution completes or the request reaches an error. The
	// operation can also be queried using [Operations
	// API][google.longrunning.Operations.GetOperation].
	//
	// The server NEED NOT implement other methods or functionality of the
	// Operations API.
	//
	// Errors discovered during creation of the `Operation` will be reported
	// as gRPC Status errors, while errors that occurred while running the
	// action will be reported in the `status` field of the `ExecuteResponse`. The
	// server MUST NOT set the `error` field of the `Operation` proto.
	// The possible errors include:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
	//   action requested, such as a missing input or command or no worker being
	//   available. The client may be able to fix the errors and retry.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
	//   the action.
	// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
	//   occupied (and the server does not support a queue), the action could not
	//   be started. The client should retry.
	// * `INTERNAL`: An internal error occurred in the execution engine or the
	//   worker.
	// * `DEADLINE_EXCEEDED`: The execution timed out.
	// * `CANCELLED`: The operation was cancelled by the client. This status is
	//   only possible if the server implements the Operations API CancelOperation
	//   method, and it was called for the current execution.
	//
	// In the case of a missing input or command, the server SHOULD additionally
	// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
	// where, for each requested blob not present in the CAS, there is a
	// `Violation` with a `type` of `MISSING` and a `subject` of
	// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
	//
	// The server does not need to guarantee that a call to this method leads to
	// at most one execution of the action. The server MAY execute the action
	// multiple times, potentially in parallel. These redundant executions MAY
	// continue to run, even if the operation is completed.
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (Execution_ExecuteClient, error)
	// Wait for an execution operation to complete. When the client initially
	// makes the request, the server immediately responds with the current status
	// of the execution. The server will leave the request stream open until the
	// operation completes, and then respond with the completed operation. The
	// server MAY choose to stream additional updates as execution progresses,
	// such as to provide an update as to the state of the execution.
	WaitExecution(ctx context.Context, in *WaitExecutionRequest, opts ...grpc.CallOption) (Execution_WaitExecutionClient, error)
}

type executionClient struct {
	cc *grpc.ClientConn
}

func NewExecutionClient(cc *grpc.ClientConn) ExecutionClient {
	return &executionClient{cc}
}

func (c *executionClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (Execution_ExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Execution_serviceDesc.Streams[0], "/build.bazel.remote.execution.v2.Execution/Execute", opts...)
	if err != nil {
		return nil, err
	}
	x := &executionExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Execution_ExecuteClient interface {
	Recv() (*longrunning.Operation, error)
	grpc.ClientStream
}

type executionExecuteClient struct {
	grpc.ClientStream
}

func (x *executionExecuteClient) Recv() (*longrunning.Operation, error) {
	m := new(longrunning.Operation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *executionClient) WaitExecution(ctx context.Context, in *WaitExecutionRequest, opts ...grpc.CallOption) (Execution_WaitExecutionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Execution_serviceDesc.Streams[1], "/build.bazel.remote.execution.v2.Execution/WaitExecution", opts...)
	if err != nil {
		return nil, err
	}
	x := &executionWaitExecutionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Execution_WaitExecutionClient interface {
	Recv() (*longrunning.Operation, error)
	grpc.ClientStream
}

type executionWaitExecutionClient struct {
	grpc.ClientStream
}

func (x *executionWaitExecutionClient) Recv() (*longrunning.Operation, error) {
	m := new(longrunning.Operation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExecutionServer is the server API for Execution service.
type ExecutionServer interface {
	// Execute an action remotely.
	//
	// In order to execute an action, the client must first upload all of the
	// inputs, the
	// [Command][build.bazel.remote.execution.v2.Command] to run, and the
	// [Action][build.bazel.remote.execution.v2.Action] into the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	// It then calls `Execute` with an `action_digest` referring to them. The
	// server will run the action and eventually return the result.
	//
	// The input `Action`'s fields MUST meet the various canonicalization
	// requirements specified in the documentation for their types so that it has
	// the same digest as other logically equivalent `Action`s. The server MAY
	// enforce the requirements and return errors if a non-canonical input is
	// received. It MAY also proceed without verifying some or all of the
	// requirements, such as for performance reasons. If the server does not
	// verify the requirement, then it will treat the `Action` as distinct from
	// another logically equivalent action if they hash differently.
	//
	// Returns a stream of
	// [google.longrunning.Operation][google.longrunning.Operation] messages
	// describing the resulting execution, with eventual `response`
	// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
	// `metadata` on the operation is of type
	// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
	//
	// If the client remains connected after the first response is returned after
	// the server, then updates are streamed as if the client had called
	// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
	// until the execution completes or the request reaches an error. The
	// operation can also be queried using [Operations
	// API][google.longrunning.Operations.GetOperation].
	//
	// The server NEED NOT implement other methods or functionality of the
	// Operations API.
	//
	// Errors discovered during creation of the `Operation` will be reported
	// as gRPC Status errors, while errors that occurred while running the
	// action will be reported in the `status` field of the `ExecuteResponse`. The
	// server MUST NOT set the `error` field of the `Operation` proto.
	// The possible errors include:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
	//   action requested, such as a missing input or command or no worker being
	//   available. The client may be able to fix the errors and retry.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
	//   the action.
	// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
	//   occupied (and the server does not support a queue), the action could not
	//   be started. The client should retry.
	// * `INTERNAL`: An internal error occurred in the execution engine or the
	//   worker.
	// * `DEADLINE_EXCEEDED`: The execution timed out.
	// * `CANCELLED`: The operation was cancelled by the client. This status is
	//   only possible if the server implements the Operations API CancelOperation
	//   method, and it was called for the current execution.
	//
	// In the case of a missing input or command, the server SHOULD additionally
	// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
	// where, for each requested blob not present in the CAS, there is a
	// `Violation` with a `type` of `MISSING` and a `subject` of
	// `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
	//
	// The server does not need to guarantee that a call to this method leads to
	// at most one execution of the action. The server MAY execute the action
	// multiple times, potentially in parallel. These redundant executions MAY
	// continue to run, even if the operation is completed.
	Execute(*ExecuteRequest, Execution_ExecuteServer) error
	// Wait for an execution operation to complete. When the client initially
	// makes the request, the server immediately responds with the current status
	// of the execution. The server will leave the request stream open until the
	// operation completes, and then respond with the completed operation. The
	// server MAY choose to stream additional updates as execution progresses,
	// such as to provide an update as to the state of the execution.
	WaitExecution(*WaitExecutionRequest, Execution_WaitExecutionServer) error
}

// UnimplementedExecutionServer can be embedded to have forward compatible implementations.
type UnimplementedExecutionServer struct {
}

func (*UnimplementedExecutionServer) Execute(req *ExecuteRequest, srv Execution_ExecuteServer) error {
	return status1.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (*UnimplementedExecutionServer) WaitExecution(req *WaitExecutionRequest, srv Execution_WaitExecutionServer) error {
	return status1.Errorf(codes.Unimplemented, "method WaitExecution not implemented")
}

func RegisterExecutionServer(s *grpc.Server, srv ExecutionServer) {
	s.RegisterService(&_Execution_serviceDesc, srv)
}

func _Execution_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecutionServer).Execute(m, &executionExecuteServer{stream})
}

type Execution_ExecuteServer interface {
	Send(*longrunning.Operation) error
	grpc.ServerStream
}

type executionExecuteServer struct {
	grpc.ServerStream
}

func (x *executionExecuteServer) Send(m *longrunning.Operation) error {
	return x.ServerStream.SendMsg(m)
}

func _Execution_WaitExecution_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WaitExecutionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecutionServer).WaitExecution(m, &executionWaitExecutionServer{stream})
}

type Execution_WaitExecutionServer interface {
	Send(*longrunning.Operation) error
	grpc.ServerStream
}

type executionWaitExecutionServer struct {
	grpc.ServerStream
}

func (x *executionWaitExecutionServer) Send(m *longrunning.Operation) error {
	return x.ServerStream.SendMsg(m)
}

var _Execution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.execution.v2.Execution",
	HandlerType: (*ExecutionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Execute",
			Handler:       _Execution_Execute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WaitExecution",
			Handler:       _Execution_WaitExecution_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "build/bazel/remote/execution/v2/remote_execution.proto",
}

// ActionCacheClient is the client API for ActionCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ActionCacheClient interface {
	// Retrieve a cached execution result.
	//
	// Implementations SHOULD ensure that any blobs referenced from the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// are available at the time of returning the
	// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
	// for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
	// if necessary and applicable.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
	GetActionResult(ctx context.Context, in *GetActionResultRequest, opts ...grpc.CallOption) (*ActionResult, error)
	// Upload a new execution result.
	//
	// In order to allow the server to perform access control based on the type of
	// action, and to assist with client debugging, the client MUST first upload
	// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
	// result, along with its
	// [Command][build.bazel.remote.execution.v2.Command], into the
	// `ContentAddressableStorage`.
	//
	// Server implementations MAY modify the
	// `UpdateActionResultRequest.action_result` and return an equivalent value.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
	//   action result, such as a missing command or action.
	// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
	//   entry to the cache.
	UpdateActionResult(ctx context.Context, in *UpdateActionResultRequest, opts ...grpc.CallOption) (*ActionResult, error)
}

type actionCacheClient struct {
	cc *grpc.ClientConn
}

func NewActionCacheClient(cc *grpc.ClientConn) ActionCacheClient {
	return &actionCacheClient{cc}
}

func (c *actionCacheClient) GetActionResult(ctx context.Context, in *GetActionResultRequest, opts ...grpc.CallOption) (*ActionResult, error) {
	out := new(ActionResult)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.ActionCache/GetActionResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionCacheClient) UpdateActionResult(ctx context.Context, in *UpdateActionResultRequest, opts ...grpc.CallOption) (*ActionResult, error) {
	out := new(ActionResult)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.ActionCache/UpdateActionResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActionCacheServer is the server API for ActionCache service.
type ActionCacheServer interface {
	// Retrieve a cached execution result.
	//
	// Implementations SHOULD ensure that any blobs referenced from the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// are available at the time of returning the
	// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
	// for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
	// if necessary and applicable.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
	GetActionResult(context.Context, *GetActionResultRequest) (*ActionResult, error)
	// Upload a new execution result.
	//
	// In order to allow the server to perform access control based on the type of
	// action, and to assist with client debugging, the client MUST first upload
	// the [Action][build.bazel.remote.execution.v2.Execution] that produced the
	// result, along with its
	// [Command][build.bazel.remote.execution.v2.Command], into the
	// `ContentAddressableStorage`.
	//
	// Server implementations MAY modify the
	// `UpdateActionResultRequest.action_result` and return an equivalent value.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
	//   action result, such as a missing command or action.
	// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
	//   entry to the cache.
	UpdateActionResult(context.Context, *UpdateActionResultRequest) (*ActionResult, error)
}

// UnimplementedActionCacheServer can be embedded to have forward compatible implementations.
type UnimplementedActionCacheServer struct {
}

func (*UnimplementedActionCacheServer) GetActionResult(ctx context.Context, req *GetActionResultRequest) (*ActionResult, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetActionResult not implemented")
}
func (*UnimplementedActionCacheServer) UpdateActionResult(ctx context.Context, req *UpdateActionResultRequest) (*ActionResult, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method UpdateActionResult not implemented")
}

func RegisterActionCacheServer(s *grpc.Server, srv ActionCacheServer) {
	s.RegisterService(&_ActionCache_serviceDesc, srv)
}

func _ActionCache_GetActionResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActionResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionCacheServer).GetActionResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.ActionCache/GetActionResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionCacheServer).GetActionResult(ctx, req.(*GetActionResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionCache_UpdateActionResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateActionResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionCacheServer).UpdateActionResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.ActionCache/UpdateActionResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionCacheServer).UpdateActionResult(ctx, req.(*UpdateActionResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ActionCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.execution.v2.ActionCache",
	HandlerType: (*ActionCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActionResult",
			Handler:    _ActionCache_GetActionResult_Handler,
		},
		{
			MethodName: "UpdateActionResult",
			Handler:    _ActionCache_UpdateActionResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "build/bazel/remote/execution/v2/remote_execution.proto",
}

// ContentAddressableStorageClient is the client API for ContentAddressableStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ContentAddressableStorageClient interface {
	// Determine if blobs are present in the CAS.
	//
	// Clients can use this API before uploading blobs to determine which ones are
	// already present in the CAS and do not need to be uploaded again.
	//
	// Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
	// applicable.
	//
	// There are no method-specific errors.
	FindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest, opts ...grpc.CallOption) (*FindMissingBlobsResponse, error)
	// Upload many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be uploaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or uploaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Write` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to upload more than the
	//   server supported limit.
	//
	// Individual requests may return the following errors, additionally:
	//
	// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
	// * `INVALID_ARGUMENT`: The
	// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
	// provided data.
	BatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest, opts ...grpc.CallOption) (*BatchUpdateBlobsResponse, error)
	// Download many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be downloaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or downloaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Read` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to read more than the
	//   server supported limit.
	//
	// Every error on individual read will be returned in the corresponding digest
	// status.
	BatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest, opts ...grpc.CallOption) (*BatchReadBlobsResponse, error)
	// Fetch the entire directory tree rooted at a node.
	//
	// This request must be targeted at a
	// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// (CAS). The server will enumerate the `Directory` tree recursively and
	// return every node descended from the root.
	//
	// The GetTreeRequest.page_token parameter can be used to skip ahead in
	// the stream (e.g. when retrying a partially completed and aborted request),
	// by setting it to a value taken from GetTreeResponse.next_page_token of the
	// last successfully processed GetTreeResponse).
	//
	// The exact traversal order is unspecified and, unless retrieving subsequent
	// pages from an earlier request, is not guaranteed to be stable across
	// multiple invocations of `GetTree`.
	//
	// If part of the tree is missing from the CAS, the server will return the
	// portion present and omit the rest.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested tree root is not present in the CAS.
	GetTree(ctx context.Context, in *GetTreeRequest, opts ...grpc.CallOption) (ContentAddressableStorage_GetTreeClient, error)
}

type contentAddressableStorageClient struct {
	cc *grpc.ClientConn
}

func NewContentAddressableStorageClient(cc *grpc.ClientConn) ContentAddressableStorageClient {
	return &contentAddressableStorageClient{cc}
}

func (c *contentAddressableStorageClient) FindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest, opts ...grpc.CallOption) (*FindMissingBlobsResponse, error) {
	out := new(FindMissingBlobsResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.ContentAddressableStorage/FindMissingBlobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentAddressableStorageClient) BatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest, opts ...grpc.CallOption) (*BatchUpdateBlobsResponse, error) {
	out := new(BatchUpdateBlobsResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchUpdateBlobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentAddressableStorageClient) BatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest, opts ...grpc.CallOption) (*BatchReadBlobsResponse, error) {
	out := new(BatchReadBlobsResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchReadBlobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contentAddressableStorageClient) GetTree(ctx context.Context, in *GetTreeRequest, opts ...grpc.CallOption) (ContentAddressableStorage_GetTreeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ContentAddressableStorage_serviceDesc.Streams[0], "/build.bazel.remote.execution.v2.ContentAddressableStorage/GetTree", opts...)
	if err != nil {
		return nil, err
	}
	x := &contentAddressableStorageGetTreeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ContentAddressableStorage_GetTreeClient interface {
	Recv() (*GetTreeResponse, error)
	grpc.ClientStream
}

type contentAddressableStorageGetTreeClient struct {
	grpc.ClientStream
}

func (x *contentAddressableStorageGetTreeClient) Recv() (*GetTreeResponse, error) {
	m := new(GetTreeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ContentAddressableStorageServer is the server API for ContentAddressableStorage service.
type ContentAddressableStorageServer interface {
	// Determine if blobs are present in the CAS.
	//
	// Clients can use this API before uploading blobs to determine which ones are
	// already present in the CAS and do not need to be uploaded again.
	//
	// Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
	// applicable.
	//
	// There are no method-specific errors.
	FindMissingBlobs(context.Context, *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error)
	// Upload many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be uploaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or uploaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Write` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to upload more than the
	//   server supported limit.
	//
	// Individual requests may return the following errors, additionally:
	//
	// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
	// * `INVALID_ARGUMENT`: The
	// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
	// provided data.
	BatchUpdateBlobs(context.Context, *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error)
	// Download many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be downloaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or downloaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Read` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to read more than the
	//   server supported limit.
	//
	// Every error on individual read will be returned in the corresponding digest
	// status.
	BatchReadBlobs(context.Context, *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error)
	// Fetch the entire directory tree rooted at a node.
	//
	// This request must be targeted at a
	// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// (CAS). The server will enumerate the `Directory` tree recursively and
	// return every node descended from the root.
	//
	// The GetTreeRequest.page_token parameter can be used to skip ahead in
	// the stream (e.g. when retrying a partially completed and aborted request),
	// by setting it to a value taken from GetTreeResponse.next_page_token of the
	// last successfully processed GetTreeResponse).
	//
	// The exact traversal order is unspecified and, unless retrieving subsequent
	// pages from an earlier request, is not guaranteed to be stable across
	// multiple invocations of `GetTree`.
	//
	// If part of the tree is missing from the CAS, the server will return the
	// portion present and omit the rest.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested tree root is not present in the CAS.
	GetTree(*GetTreeRequest, ContentAddressableStorage_GetTreeServer) error
}

// UnimplementedContentAddressableStorageServer can be embedded to have forward compatible implementations.
type UnimplementedContentAddressableStorageServer struct {
}

func (*UnimplementedContentAddressableStorageServer) FindMissingBlobs(ctx context.Context, req *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method FindMissingBlobs not implemented")
}
func (*UnimplementedContentAddressableStorageServer) BatchUpdateBlobs(ctx context.Context, req *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method BatchUpdateBlobs not implemented")
}
func (*UnimplementedContentAddressableStorageServer) BatchReadBlobs(ctx context.Context, req *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method BatchReadBlobs not implemented")
}
func (*UnimplementedContentAddressableStorageServer) GetTree(req *GetTreeRequest, srv ContentAddressableStorage_GetTreeServer) error {
	return status1.Errorf(codes.Unimplemented, "method GetTree not implemented")
}

func RegisterContentAddressableStorageServer(s *grpc.Server, srv ContentAddressableStorageServer) {
	s.RegisterService(&_ContentAddressableStorage_serviceDesc, srv)
}

func _ContentAddressableStorage_FindMissingBlobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindMissingBlobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentAddressableStorageServer).FindMissingBlobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.ContentAddressableStorage/FindMissingBlobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentAddressableStorageServer).FindMissingBlobs(ctx, req.(*FindMissingBlobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentAddressableStorage_BatchUpdateBlobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateBlobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentAddressableStorageServer).BatchUpdateBlobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchUpdateBlobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentAddressableStorageServer).BatchUpdateBlobs(ctx, req.(*BatchUpdateBlobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentAddressableStorage_BatchReadBlobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchReadBlobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentAddressableStorageServer).BatchReadBlobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.ContentAddressableStorage/BatchReadBlobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentAddressableStorageServer).BatchReadBlobs(ctx, req.(*BatchReadBlobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContentAddressableStorage_GetTree_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTreeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContentAddressableStorageServer).GetTree(m, &contentAddressableStorageGetTreeServer{stream})
}

type ContentAddressableStorage_GetTreeServer interface {
	Send(*GetTreeResponse) error
	grpc.ServerStream
}

type contentAddressableStorageGetTreeServer struct {
	grpc.ServerStream
}

func (x *contentAddressableStorageGetTreeServer) Send(m *GetTreeResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ContentAddressableStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.execution.v2.ContentAddressableStorage",
	HandlerType: (*ContentAddressableStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindMissingBlobs",
			Handler:    _ContentAddressableStorage_FindMissingBlobs_Handler,
		},
		{
			MethodName: "BatchUpdateBlobs",
			Handler:    _ContentAddressableStorage_BatchUpdateBlobs_Handler,
		},
		{
			MethodName: "BatchReadBlobs",
			Handler:    _ContentAddressableStorage_BatchReadBlobs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTree",
			Handler:       _ContentAddressableStorage_GetTree_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "build/bazel/remote/execution/v2/remote_execution.proto",
}

// CapabilitiesClient is the client API for Capabilities service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CapabilitiesClient interface {
	// GetCapabilities returns the server capabilities configuration of the
	// remote endpoint.
	// Only the capabilities of the services supported by the endpoint will
	// be returned:
	// * Execution + CAS + Action Cache endpoints should return both
	//   CacheCapabilities and ExecutionCapabilities.
	// * Execution only endpoints should return ExecutionCapabilities.
	// * CAS + Action Cache only endpoints should return CacheCapabilities.
	GetCapabilities(ctx context.Context, in *GetCapabilitiesRequest, opts ...grpc.CallOption) (*ServerCapabilities, error)
}

type capabilitiesClient struct {
	cc *grpc.ClientConn
}

func NewCapabilitiesClient(cc *grpc.ClientConn) CapabilitiesClient {
	return &capabilitiesClient{cc}
}

func (c *capabilitiesClient) GetCapabilities(ctx context.Context, in *GetCapabilitiesRequest, opts ...grpc.CallOption) (*ServerCapabilities, error) {
	out := new(ServerCapabilities)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.execution.v2.Capabilities/GetCapabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CapabilitiesServer is the server API for Capabilities service.
type CapabilitiesServer interface {
	// GetCapabilities returns the server capabilities configuration of the
	// remote endpoint.
	// Only the capabilities of the services supported by the endpoint will
	// be returned:
	// * Execution + CAS + Action Cache endpoints should return both
	//   CacheCapabilities and ExecutionCapabilities.
	// * Execution only endpoints should return ExecutionCapabilities.
	// * CAS + Action Cache only endpoints should return CacheCapabilities.
	GetCapabilities(context.Context, *GetCapabilitiesRequest) (*ServerCapabilities, error)
}

// UnimplementedCapabilitiesServer can be embedded to have forward compatible implementations.
type UnimplementedCapabilitiesServer struct {
}

func (*UnimplementedCapabilitiesServer) GetCapabilities(ctx context.Context, req *GetCapabilitiesRequest) (*ServerCapabilities, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetCapabilities not implemented")
}

func RegisterCapabilitiesServer(s *grpc.Server, srv CapabilitiesServer) {
	s.RegisterService(&_Capabilities_serviceDesc, srv)
}

func _Capabilities_GetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CapabilitiesServer).GetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.execution.v2.Capabilities/GetCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CapabilitiesServer).GetCapabilities(ctx, req.(*GetCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Capabilities_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.execution.v2.Capabilities",
	HandlerType: (*CapabilitiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCapabilities",
			Handler:    _Capabilities_GetCapabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "build/bazel/remote/execution/v2/remote_execution.proto",
}
