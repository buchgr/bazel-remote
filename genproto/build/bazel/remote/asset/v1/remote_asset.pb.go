// Code generated by protoc-gen-go. DO NOT EDIT.
// source: build/bazel/remote/asset/v1/remote_asset.proto

package remoteasset

import (
	context "context"
	fmt "fmt"
	v2 "github.com/buchgr/bazel-remote/genproto/build/bazel/remote/execution/v2"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Qualifiers are used to disambiguate or sub-select content that shares a URI.
// This may include specifying a particular commit or branch, in the case of
// URIs referencing a repository; they could also be used to specify a
// particular subdirectory of a repository or tarball. Qualifiers may also be
// used to ensure content matches what the client expects, even when there is
// no ambiguity to be had - for example, a qualifier specifying a checksum
// value.
//
// In cases where the semantics of the request are not immediately clear from
// the URL and/or qualifiers - e.g. dictated by URL scheme - it is recommended
// to use an additional qualifier to remove the ambiguity. The `resource_type`
// qualifier is recommended for this purpose.
//
// Qualifiers may be supplied in any order.
type Qualifier struct {
	// The "name" of the qualifier, for example "resource_type".
	// No separation is made between 'standard' and 'nonstandard'
	// qualifiers, in accordance with https://tools.ietf.org/html/rfc6648,
	// however implementers *SHOULD* take care to avoid ambiguity.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The "value" of the qualifier. Semantics will be dictated by the name.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Qualifier) Reset()         { *m = Qualifier{} }
func (m *Qualifier) String() string { return proto.CompactTextString(m) }
func (*Qualifier) ProtoMessage()    {}
func (*Qualifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{0}
}

func (m *Qualifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Qualifier.Unmarshal(m, b)
}
func (m *Qualifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Qualifier.Marshal(b, m, deterministic)
}
func (m *Qualifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Qualifier.Merge(m, src)
}
func (m *Qualifier) XXX_Size() int {
	return xxx_messageInfo_Qualifier.Size(m)
}
func (m *Qualifier) XXX_DiscardUnknown() {
	xxx_messageInfo_Qualifier.DiscardUnknown(m)
}

var xxx_messageInfo_Qualifier proto.InternalMessageInfo

func (m *Qualifier) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Qualifier) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A request message for
// [Fetch.FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
type FetchBlobRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The timeout for the underlying fetch, if content needs to be retrieved from
	// origin.
	//
	// If unset, the server *MAY* apply an implementation-defined timeout.
	//
	// If set, and the user-provided timeout exceeds the RPC deadline, the server
	// *SHOULD* keep the fetch going after the RPC completes, to be made
	// available for future Fetch calls. The server may also enforce (via clamping
	// and/or an INVALID_ARGUMENT error) implementation-defined minimum and
	// maximum timeout values.
	//
	// If this timeout is exceeded on an attempt to retrieve content from origin
	// the client will receive DEADLINE_EXCEEDED in [FetchBlobResponse.status].
	Timeout *duration.Duration `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// The oldest content the client is willing to accept, as measured from the
	// time it was Push'd or when the underlying retrieval from origin was
	// started.
	// Upon retries of Fetch requests that cannot be completed within a single
	// RPC, clients *SHOULD* provide the same value for subsequent requests as the
	// original, to simplify combining the request with the previous attempt.
	//
	// If unset, the client *SHOULD* accept content of any age.
	OldestContentAccepted *timestamp.Timestamp `protobuf:"bytes,3,opt,name=oldest_content_accepted,json=oldestContentAccepted,proto3" json:"oldest_content_accepted,omitempty"`
	// The URI(s) of the content to fetch. These may be resources that the server
	// can directly fetch from origin, in which case multiple URIs *SHOULD*
	// represent the same content available at different locations (such as an
	// origin and secondary mirrors). These may also be URIs for content known to
	// the server through other mechanisms, e.g. pushed via the [Push][build.bazel.remote.asset.v1.Push]
	// service.
	//
	// Clients *MUST* supply at least one URI. Servers *MAY* match any one of the
	// supplied URIs.
	Uris []string `protobuf:"bytes,4,rep,name=uris,proto3" json:"uris,omitempty"`
	// Qualifiers sub-specifying the content to fetch - see comments on
	// [Qualifier][build.bazel.remote.asset.v1.Qualifier].
	// The same qualifiers apply to all URIs.
	//
	// Specified qualifier names *MUST* be unique.
	Qualifiers           []*Qualifier `protobuf:"bytes,5,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FetchBlobRequest) Reset()         { *m = FetchBlobRequest{} }
func (m *FetchBlobRequest) String() string { return proto.CompactTextString(m) }
func (*FetchBlobRequest) ProtoMessage()    {}
func (*FetchBlobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{1}
}

func (m *FetchBlobRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FetchBlobRequest.Unmarshal(m, b)
}
func (m *FetchBlobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FetchBlobRequest.Marshal(b, m, deterministic)
}
func (m *FetchBlobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlobRequest.Merge(m, src)
}
func (m *FetchBlobRequest) XXX_Size() int {
	return xxx_messageInfo_FetchBlobRequest.Size(m)
}
func (m *FetchBlobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlobRequest proto.InternalMessageInfo

func (m *FetchBlobRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *FetchBlobRequest) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *FetchBlobRequest) GetOldestContentAccepted() *timestamp.Timestamp {
	if m != nil {
		return m.OldestContentAccepted
	}
	return nil
}

func (m *FetchBlobRequest) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *FetchBlobRequest) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

// A response message for
// [Fetch.FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
type FetchBlobResponse struct {
	// If the status has a code other than `OK`, it indicates that the operation
	// was unable to be completed for reasons outside the servers' control.
	// The possible fetch errors include:
	// * `DEADLINE_EXCEEDED`: The operation could not be completed within the
	//   specified timeout.
	// * `NOT_FOUND`: The requested asset was not found at the specified location.
	// * `PERMISSION_DENIED`: The request was rejected by a remote server, or
	//   requested an asset from a disallowed origin.
	// * `ABORTED`: The operation could not be completed, typically due to a
	//   failed consistency check.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The uri from the request that resulted in a successful retrieval, or from
	// which the error indicated in `status` was obtained.
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// Any qualifiers known to the server and of interest to clients.
	Qualifiers []*Qualifier `protobuf:"bytes,3,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	// A minimum timestamp the content is expected to be available through.
	// Servers *MAY* omit this field, if not known with confidence.
	ExpiresAt *timestamp.Timestamp `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// The result of the fetch, if the status had code `OK`.
	// The digest of the file's contents, available for download through the CAS.
	BlobDigest           *v2.Digest `protobuf:"bytes,5,opt,name=blob_digest,json=blobDigest,proto3" json:"blob_digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *FetchBlobResponse) Reset()         { *m = FetchBlobResponse{} }
func (m *FetchBlobResponse) String() string { return proto.CompactTextString(m) }
func (*FetchBlobResponse) ProtoMessage()    {}
func (*FetchBlobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{2}
}

func (m *FetchBlobResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FetchBlobResponse.Unmarshal(m, b)
}
func (m *FetchBlobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FetchBlobResponse.Marshal(b, m, deterministic)
}
func (m *FetchBlobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBlobResponse.Merge(m, src)
}
func (m *FetchBlobResponse) XXX_Size() int {
	return xxx_messageInfo_FetchBlobResponse.Size(m)
}
func (m *FetchBlobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBlobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBlobResponse proto.InternalMessageInfo

func (m *FetchBlobResponse) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *FetchBlobResponse) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *FetchBlobResponse) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

func (m *FetchBlobResponse) GetExpiresAt() *timestamp.Timestamp {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *FetchBlobResponse) GetBlobDigest() *v2.Digest {
	if m != nil {
		return m.BlobDigest
	}
	return nil
}

// A request message for
// [Fetch.FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
type FetchDirectoryRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The timeout for the underlying fetch, if content needs to be retrieved from
	// origin. This value is allowed to exceed the RPC deadline, in which case the
	// server *SHOULD* keep the fetch going after the RPC completes, to be made
	// available for future Fetch calls.
	//
	// If this timeout is exceeded on an attempt to retrieve content from origin
	// the client will receive DEADLINE_EXCEEDED in [FetchDirectoryResponse.status].
	Timeout *duration.Duration `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// The oldest content the client is willing to accept, as measured from the
	// time it was Push'd or when the underlying retrieval from origin was
	// started.
	// Upon retries of Fetch requests that cannot be completed within a single
	// RPC, clients *SHOULD* provide the same value for subsequent requests as the
	// original, to simplify combining the request with the previous attempt.
	//
	// If unset, the client *SHOULD* accept content of any age.
	OldestContentAccepted *timestamp.Timestamp `protobuf:"bytes,3,opt,name=oldest_content_accepted,json=oldestContentAccepted,proto3" json:"oldest_content_accepted,omitempty"`
	// The URI(s) of the content to fetch. These may be resources that the server
	// can directly fetch from origin, in which case multiple URIs *SHOULD*
	// represent the same content available at different locations (such as an
	// origin and secondary mirrors). These may also be URIs for content known to
	// the server through other mechanisms, e.g. pushed via the [Push][build.bazel.remote.asset.v1.Push]
	// service.
	//
	// Clients *MUST* supply at least one URI. Servers *MAY* match any one of the
	// supplied URIs.
	Uris []string `protobuf:"bytes,4,rep,name=uris,proto3" json:"uris,omitempty"`
	// Qualifiers sub-specifying the content to fetch - see comments on
	// [Qualifier][build.bazel.remote.asset.v1.Qualifier].
	// The same qualifiers apply to all URIs.
	//
	// Specified qualifier names *MUST* be unique.
	Qualifiers           []*Qualifier `protobuf:"bytes,5,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FetchDirectoryRequest) Reset()         { *m = FetchDirectoryRequest{} }
func (m *FetchDirectoryRequest) String() string { return proto.CompactTextString(m) }
func (*FetchDirectoryRequest) ProtoMessage()    {}
func (*FetchDirectoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{3}
}

func (m *FetchDirectoryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FetchDirectoryRequest.Unmarshal(m, b)
}
func (m *FetchDirectoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FetchDirectoryRequest.Marshal(b, m, deterministic)
}
func (m *FetchDirectoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDirectoryRequest.Merge(m, src)
}
func (m *FetchDirectoryRequest) XXX_Size() int {
	return xxx_messageInfo_FetchDirectoryRequest.Size(m)
}
func (m *FetchDirectoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDirectoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDirectoryRequest proto.InternalMessageInfo

func (m *FetchDirectoryRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *FetchDirectoryRequest) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *FetchDirectoryRequest) GetOldestContentAccepted() *timestamp.Timestamp {
	if m != nil {
		return m.OldestContentAccepted
	}
	return nil
}

func (m *FetchDirectoryRequest) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *FetchDirectoryRequest) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

// A response message for
// [Fetch.FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
type FetchDirectoryResponse struct {
	// If the status has a code other than `OK`, it indicates that the operation
	// was unable to be completed for reasons outside the servers' control.
	// The possible fetch errors include:
	// * `DEADLINE_EXCEEDED`: The operation could not be completed within the
	//   specified timeout.
	// * `NOT_FOUND`: The requested asset was not found at the specified location.
	// * `PERMISSION_DENIED`: The request was rejected by a remote server, or
	//   requested an asset from a disallowed origin.
	// * `ABORTED`: The operation could not be completed, typically due to a
	//   failed consistency check.
	Status *status.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The uri from the request that resulted in a successful retrieval, or from
	// which the error indicated in `status` was obtained.
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// Any qualifiers known to the server and of interest to clients.
	Qualifiers []*Qualifier `protobuf:"bytes,3,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	// A minimum timestamp the content is expected to be available through.
	// Servers *MAY* omit this field, if not known with confidence.
	ExpiresAt *timestamp.Timestamp `protobuf:"bytes,4,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// The result of the fetch, if the status had code `OK`.
	// the root digest of a directory tree, suitable for fetching via
	// [ContentAddressableStorage.GetTree].
	RootDirectoryDigest  *v2.Digest `protobuf:"bytes,5,opt,name=root_directory_digest,json=rootDirectoryDigest,proto3" json:"root_directory_digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *FetchDirectoryResponse) Reset()         { *m = FetchDirectoryResponse{} }
func (m *FetchDirectoryResponse) String() string { return proto.CompactTextString(m) }
func (*FetchDirectoryResponse) ProtoMessage()    {}
func (*FetchDirectoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{4}
}

func (m *FetchDirectoryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FetchDirectoryResponse.Unmarshal(m, b)
}
func (m *FetchDirectoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FetchDirectoryResponse.Marshal(b, m, deterministic)
}
func (m *FetchDirectoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDirectoryResponse.Merge(m, src)
}
func (m *FetchDirectoryResponse) XXX_Size() int {
	return xxx_messageInfo_FetchDirectoryResponse.Size(m)
}
func (m *FetchDirectoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDirectoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDirectoryResponse proto.InternalMessageInfo

func (m *FetchDirectoryResponse) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *FetchDirectoryResponse) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *FetchDirectoryResponse) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

func (m *FetchDirectoryResponse) GetExpiresAt() *timestamp.Timestamp {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *FetchDirectoryResponse) GetRootDirectoryDigest() *v2.Digest {
	if m != nil {
		return m.RootDirectoryDigest
	}
	return nil
}

// A request message for
// [Push.PushBlob][build.bazel.remote.asset.v1.Push.PushBlob].
type PushBlobRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The URI(s) of the content to associate. If multiple URIs are specified, the
	// pushed content will be available to fetch by specifying any of them.
	Uris []string `protobuf:"bytes,2,rep,name=uris,proto3" json:"uris,omitempty"`
	// Qualifiers sub-specifying the content that is being pushed - see comments
	// on [Qualifier][build.bazel.remote.asset.v1.Qualifier].
	// The same qualifiers apply to all URIs.
	Qualifiers []*Qualifier `protobuf:"bytes,3,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	// A time after which this content should stop being returned via [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob].
	// Servers *MAY* expire content early, e.g. due to storage pressure.
	ExpireAt *timestamp.Timestamp `protobuf:"bytes,4,opt,name=expire_at,json=expireAt,proto3" json:"expire_at,omitempty"`
	// The blob to associate.
	BlobDigest *v2.Digest `protobuf:"bytes,5,opt,name=blob_digest,json=blobDigest,proto3" json:"blob_digest,omitempty"`
	// Referenced blobs or directories that need to not expire before expiration
	// of this association, in addition to `blob_digest` itself.
	// These fields are hints - clients *MAY* omit them, and servers *SHOULD*
	// respect them, at the risk of increased incidents of Fetch responses
	// indirectly referencing unavailable blobs.
	ReferencesBlobs       []*v2.Digest `protobuf:"bytes,6,rep,name=references_blobs,json=referencesBlobs,proto3" json:"references_blobs,omitempty"`
	ReferencesDirectories []*v2.Digest `protobuf:"bytes,7,rep,name=references_directories,json=referencesDirectories,proto3" json:"references_directories,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *PushBlobRequest) Reset()         { *m = PushBlobRequest{} }
func (m *PushBlobRequest) String() string { return proto.CompactTextString(m) }
func (*PushBlobRequest) ProtoMessage()    {}
func (*PushBlobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{5}
}

func (m *PushBlobRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushBlobRequest.Unmarshal(m, b)
}
func (m *PushBlobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushBlobRequest.Marshal(b, m, deterministic)
}
func (m *PushBlobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBlobRequest.Merge(m, src)
}
func (m *PushBlobRequest) XXX_Size() int {
	return xxx_messageInfo_PushBlobRequest.Size(m)
}
func (m *PushBlobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBlobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushBlobRequest proto.InternalMessageInfo

func (m *PushBlobRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *PushBlobRequest) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *PushBlobRequest) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

func (m *PushBlobRequest) GetExpireAt() *timestamp.Timestamp {
	if m != nil {
		return m.ExpireAt
	}
	return nil
}

func (m *PushBlobRequest) GetBlobDigest() *v2.Digest {
	if m != nil {
		return m.BlobDigest
	}
	return nil
}

func (m *PushBlobRequest) GetReferencesBlobs() []*v2.Digest {
	if m != nil {
		return m.ReferencesBlobs
	}
	return nil
}

func (m *PushBlobRequest) GetReferencesDirectories() []*v2.Digest {
	if m != nil {
		return m.ReferencesDirectories
	}
	return nil
}

// A response message for
// [Push.PushBlob][build.bazel.remote.asset.v1.Push.PushBlob].
type PushBlobResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushBlobResponse) Reset()         { *m = PushBlobResponse{} }
func (m *PushBlobResponse) String() string { return proto.CompactTextString(m) }
func (*PushBlobResponse) ProtoMessage()    {}
func (*PushBlobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{6}
}

func (m *PushBlobResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushBlobResponse.Unmarshal(m, b)
}
func (m *PushBlobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushBlobResponse.Marshal(b, m, deterministic)
}
func (m *PushBlobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushBlobResponse.Merge(m, src)
}
func (m *PushBlobResponse) XXX_Size() int {
	return xxx_messageInfo_PushBlobResponse.Size(m)
}
func (m *PushBlobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushBlobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushBlobResponse proto.InternalMessageInfo

// A request message for
// [Push.PushDirectory][build.bazel.remote.asset.v1.Push.PushDirectory].
type PushDirectoryRequest struct {
	// The instance of the execution system to operate against. A server may
	// support multiple instances of the execution system (with their own workers,
	// storage, caches, etc.). The server MAY require use of this field to select
	// between them in an implementation-defined fashion, otherwise it can be
	// omitted.
	InstanceName string `protobuf:"bytes,1,opt,name=instance_name,json=instanceName,proto3" json:"instance_name,omitempty"`
	// The URI(s) of the content to associate. If multiple URIs are specified, the
	// pushed content will be available to fetch by specifying any of them.
	Uris []string `protobuf:"bytes,2,rep,name=uris,proto3" json:"uris,omitempty"`
	// Qualifiers sub-specifying the content that is being pushed - see comments
	// on [Qualifier][build.bazel.remote.asset.v1.Qualifier].
	// The same qualifiers apply to all URIs.
	Qualifiers []*Qualifier `protobuf:"bytes,3,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	// A time after which this content should stop being returned via
	// [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory].
	// Servers *MAY* expire content early, e.g. due to storage pressure.
	ExpireAt *timestamp.Timestamp `protobuf:"bytes,4,opt,name=expire_at,json=expireAt,proto3" json:"expire_at,omitempty"`
	// Directory to associate
	RootDirectoryDigest *v2.Digest `protobuf:"bytes,5,opt,name=root_directory_digest,json=rootDirectoryDigest,proto3" json:"root_directory_digest,omitempty"`
	// Referenced blobs or directories that need to not expire before expiration
	// of this association, in addition to `root_directory_digest` itself.
	// These fields are hints - clients *MAY* omit them, and servers *SHOULD*
	// respect them, at the risk of increased incidents of Fetch responses
	// indirectly referencing unavailable blobs.
	ReferencesBlobs       []*v2.Digest `protobuf:"bytes,6,rep,name=references_blobs,json=referencesBlobs,proto3" json:"references_blobs,omitempty"`
	ReferencesDirectories []*v2.Digest `protobuf:"bytes,7,rep,name=references_directories,json=referencesDirectories,proto3" json:"references_directories,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *PushDirectoryRequest) Reset()         { *m = PushDirectoryRequest{} }
func (m *PushDirectoryRequest) String() string { return proto.CompactTextString(m) }
func (*PushDirectoryRequest) ProtoMessage()    {}
func (*PushDirectoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{7}
}

func (m *PushDirectoryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushDirectoryRequest.Unmarshal(m, b)
}
func (m *PushDirectoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushDirectoryRequest.Marshal(b, m, deterministic)
}
func (m *PushDirectoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushDirectoryRequest.Merge(m, src)
}
func (m *PushDirectoryRequest) XXX_Size() int {
	return xxx_messageInfo_PushDirectoryRequest.Size(m)
}
func (m *PushDirectoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushDirectoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushDirectoryRequest proto.InternalMessageInfo

func (m *PushDirectoryRequest) GetInstanceName() string {
	if m != nil {
		return m.InstanceName
	}
	return ""
}

func (m *PushDirectoryRequest) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *PushDirectoryRequest) GetQualifiers() []*Qualifier {
	if m != nil {
		return m.Qualifiers
	}
	return nil
}

func (m *PushDirectoryRequest) GetExpireAt() *timestamp.Timestamp {
	if m != nil {
		return m.ExpireAt
	}
	return nil
}

func (m *PushDirectoryRequest) GetRootDirectoryDigest() *v2.Digest {
	if m != nil {
		return m.RootDirectoryDigest
	}
	return nil
}

func (m *PushDirectoryRequest) GetReferencesBlobs() []*v2.Digest {
	if m != nil {
		return m.ReferencesBlobs
	}
	return nil
}

func (m *PushDirectoryRequest) GetReferencesDirectories() []*v2.Digest {
	if m != nil {
		return m.ReferencesDirectories
	}
	return nil
}

// A response message for
// [Push.PushDirectory][build.bazel.remote.asset.v1.Push.PushDirectory].
type PushDirectoryResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushDirectoryResponse) Reset()         { *m = PushDirectoryResponse{} }
func (m *PushDirectoryResponse) String() string { return proto.CompactTextString(m) }
func (*PushDirectoryResponse) ProtoMessage()    {}
func (*PushDirectoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1872b94e98a76a1, []int{8}
}

func (m *PushDirectoryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PushDirectoryResponse.Unmarshal(m, b)
}
func (m *PushDirectoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PushDirectoryResponse.Marshal(b, m, deterministic)
}
func (m *PushDirectoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushDirectoryResponse.Merge(m, src)
}
func (m *PushDirectoryResponse) XXX_Size() int {
	return xxx_messageInfo_PushDirectoryResponse.Size(m)
}
func (m *PushDirectoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushDirectoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushDirectoryResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Qualifier)(nil), "build.bazel.remote.asset.v1.Qualifier")
	proto.RegisterType((*FetchBlobRequest)(nil), "build.bazel.remote.asset.v1.FetchBlobRequest")
	proto.RegisterType((*FetchBlobResponse)(nil), "build.bazel.remote.asset.v1.FetchBlobResponse")
	proto.RegisterType((*FetchDirectoryRequest)(nil), "build.bazel.remote.asset.v1.FetchDirectoryRequest")
	proto.RegisterType((*FetchDirectoryResponse)(nil), "build.bazel.remote.asset.v1.FetchDirectoryResponse")
	proto.RegisterType((*PushBlobRequest)(nil), "build.bazel.remote.asset.v1.PushBlobRequest")
	proto.RegisterType((*PushBlobResponse)(nil), "build.bazel.remote.asset.v1.PushBlobResponse")
	proto.RegisterType((*PushDirectoryRequest)(nil), "build.bazel.remote.asset.v1.PushDirectoryRequest")
	proto.RegisterType((*PushDirectoryResponse)(nil), "build.bazel.remote.asset.v1.PushDirectoryResponse")
}

func init() {
	proto.RegisterFile("build/bazel/remote/asset/v1/remote_asset.proto", fileDescriptor_f1872b94e98a76a1)
}

var fileDescriptor_f1872b94e98a76a1 = []byte{
	// 829 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0x96, 0x9d, 0xa4, 0x6d, 0x5e, 0x28, 0x0d, 0x43, 0xd3, 0x9a, 0x14, 0x41, 0x65, 0xa4, 0xb6,
	0x4a, 0x5b, 0x9b, 0xb8, 0xa2, 0x15, 0x95, 0x38, 0x24, 0x44, 0x15, 0x27, 0x54, 0x0c, 0x27, 0x90,
	0xb0, 0x1c, 0x67, 0x52, 0x2c, 0x39, 0x1e, 0xd7, 0x33, 0x8e, 0x0a, 0x88, 0x0b, 0xff, 0x02, 0x37,
	0x84, 0x2a, 0xc1, 0x91, 0x03, 0x07, 0x0e, 0xfc, 0x0f, 0x9c, 0xe1, 0xca, 0x01, 0x69, 0xff, 0x90,
	0xd5, 0x8c, 0xc7, 0x49, 0xea, 0x76, 0xf3, 0x4b, 0xbb, 0xd2, 0xee, 0x6a, 0x6f, 0x33, 0xf3, 0xde,
	0xf7, 0xf9, 0x9b, 0xef, 0x3d, 0xbf, 0x38, 0x60, 0x74, 0x13, 0x3f, 0xe8, 0x99, 0x5d, 0xf7, 0x3b,
	0x1c, 0x98, 0x31, 0x1e, 0x10, 0x86, 0x4d, 0x97, 0x52, 0xcc, 0xcc, 0x61, 0x53, 0xee, 0x1d, 0xb1,
	0x37, 0xa2, 0x98, 0x30, 0x82, 0x76, 0x44, 0xbe, 0x21, 0xf2, 0x8d, 0x34, 0x6e, 0xa4, 0xf1, 0x61,
	0xb3, 0x7e, 0xfa, 0x00, 0x19, 0xbe, 0xc1, 0x5e, 0xc2, 0x7c, 0x12, 0x9a, 0x43, 0x2b, 0x23, 0x1c,
	0x9d, 0xa5, 0xa4, 0xf5, 0xb7, 0xaf, 0x08, 0xb9, 0x0a, 0xb0, 0xe9, 0x46, 0xbe, 0xe9, 0x86, 0x21,
	0x61, 0x2e, 0x0f, 0x52, 0x19, 0x7d, 0x47, 0x46, 0xc5, 0xae, 0x9b, 0xf4, 0xcd, 0x5e, 0x12, 0xbb,
	0x13, 0xe8, 0x77, 0xf3, 0x71, 0xe6, 0x0f, 0x30, 0x65, 0xee, 0x20, 0x92, 0x09, 0xdb, 0x32, 0x21,
	0x8e, 0x3c, 0x93, 0x32, 0x97, 0x25, 0x92, 0x59, 0xff, 0x00, 0xca, 0x9f, 0x25, 0x6e, 0xe0, 0xf7,
	0x7d, 0x1c, 0x23, 0x04, 0xc5, 0xd0, 0x1d, 0x60, 0x4d, 0xd9, 0x55, 0x0e, 0xca, 0xb6, 0x58, 0xa3,
	0x4d, 0x28, 0x0d, 0xdd, 0x20, 0xc1, 0x9a, 0x2a, 0x0e, 0xd3, 0x8d, 0xfe, 0x8b, 0x0a, 0xd5, 0x0b,
	0xcc, 0xbc, 0x6f, 0xda, 0x01, 0xe9, 0xda, 0xf8, 0x3a, 0xc1, 0x94, 0xa1, 0xf7, 0x60, 0xdd, 0x0f,
	0x29, 0x73, 0x43, 0x0f, 0x3b, 0x13, 0x3c, 0xaf, 0x65, 0x87, 0x9f, 0x72, 0xbe, 0x13, 0x58, 0xe5,
	0xe2, 0x48, 0xc2, 0x04, 0x63, 0xc5, 0x7a, 0xcb, 0x48, 0xb5, 0x19, 0x99, 0x78, 0xa3, 0x23, 0x2f,
	0x67, 0x67, 0x99, 0xc8, 0x86, 0x6d, 0x12, 0xf4, 0x30, 0x65, 0x8e, 0x47, 0x42, 0x86, 0x43, 0xe6,
	0xb8, 0x9e, 0x87, 0x23, 0x86, 0x7b, 0x5a, 0x41, 0x90, 0xd4, 0xef, 0x91, 0x7c, 0x91, 0x39, 0x60,
	0xd7, 0x52, 0xe8, 0xc7, 0x29, 0xb2, 0x25, 0x81, 0xfc, 0xb2, 0x49, 0xec, 0x53, 0xad, 0xb8, 0x5b,
	0xe0, 0x97, 0xe5, 0x6b, 0x74, 0x01, 0x70, 0x9d, 0xb9, 0x41, 0xb5, 0xd2, 0x6e, 0xe1, 0xa0, 0x62,
	0xed, 0x19, 0x53, 0xea, 0x6d, 0x8c, 0xcc, 0xb3, 0x27, 0x90, 0xfa, 0xad, 0x0a, 0x6f, 0x4c, 0xd8,
	0x43, 0x23, 0x12, 0x52, 0x8c, 0x1a, 0xb0, 0x92, 0x7a, 0x2f, 0x8c, 0xa9, 0x58, 0x28, 0x13, 0x1d,
	0x47, 0x9e, 0xf1, 0xb9, 0x88, 0xd8, 0x32, 0x03, 0x55, 0xa1, 0x90, 0xc4, 0xbe, 0x34, 0x9d, 0x2f,
	0x73, 0xda, 0x0a, 0xcb, 0x6a, 0x43, 0x1f, 0x02, 0xe0, 0x9b, 0xc8, 0x8f, 0x31, 0x75, 0x5c, 0xa6,
	0x15, 0x67, 0xda, 0x57, 0x96, 0xd9, 0x2d, 0x86, 0x3e, 0x81, 0x4a, 0x37, 0x20, 0x5d, 0xa7, 0xe7,
	0x5f, 0x61, 0xca, 0xb4, 0x92, 0xc0, 0xee, 0x3f, 0xa4, 0x61, 0xdc, 0xde, 0x43, 0xcb, 0xe8, 0x88,
	0x74, 0x1b, 0x38, 0x36, 0x5d, 0xeb, 0xbf, 0xaa, 0x50, 0x13, 0x06, 0x75, 0xfc, 0x18, 0x7b, 0x8c,
	0xc4, 0xdf, 0xbe, 0x6a, 0xa2, 0x7c, 0x13, 0xfd, 0xa5, 0xc2, 0x56, 0xde, 0xa3, 0x97, 0xa5, 0x93,
	0xbe, 0x82, 0x5a, 0x4c, 0x08, 0x73, 0x7a, 0xd9, 0xd5, 0x96, 0xec, 0xa9, 0x37, 0x39, 0xcb, 0xc8,
	0x1f, 0xd9, 0x5c, 0x7f, 0x17, 0x60, 0xe3, 0x32, 0xa1, 0x8b, 0xcf, 0xa6, 0xac, 0x9a, 0xea, 0x13,
	0xab, 0xb9, 0xbc, 0x59, 0x67, 0x20, 0xaf, 0x3f, 0x9f, 0x57, 0x6b, 0x69, 0xf2, 0xd3, 0x7c, 0xe9,
	0x90, 0x0d, 0xd5, 0x18, 0xf7, 0x71, 0x8c, 0x43, 0x0f, 0x53, 0x87, 0x07, 0xa8, 0xb6, 0x22, 0x2e,
	0x34, 0x37, 0xdd, 0xc6, 0x98, 0x80, 0xbb, 0x4b, 0xd1, 0xd7, 0xb0, 0x35, 0xc1, 0x99, 0x95, 0xd3,
	0xc7, 0x54, 0x5b, 0x5d, 0x8c, 0xb9, 0x36, 0xa6, 0xe9, 0x8c, 0x59, 0x74, 0x04, 0xd5, 0x71, 0x29,
	0xd3, 0xee, 0xd7, 0xff, 0x2f, 0xc0, 0x26, 0x3f, 0x5c, 0x6e, 0x76, 0x3c, 0x97, 0x45, 0x7e, 0x96,
	0xef, 0xc3, 0x0b, 0x59, 0xf7, 0x6d, 0xa8, 0xe5, 0x4a, 0x9c, 0x16, 0xdf, 0xfa, 0x4f, 0x85, 0x92,
	0x98, 0x8a, 0xe8, 0x56, 0x81, 0xf2, 0xe8, 0x47, 0x16, 0x1d, 0x4f, 0x2d, 0x57, 0xfe, 0x5b, 0xa5,
	0x6e, 0xcc, 0x9b, 0x2e, 0x7b, 0xce, 0xfa, 0xf1, 0x9f, 0x47, 0x3f, 0xa9, 0x47, 0xfa, 0x3e, 0xff,
	0x28, 0xfc, 0xfe, 0x4e, 0x97, 0x7d, 0xd4, 0x68, 0xfc, 0x90, 0x7e, 0x30, 0xd2, 0xf3, 0x7e, 0x06,
	0x3c, 0x57, 0x1a, 0xe8, 0x4f, 0x05, 0x5e, 0xbf, 0x3b, 0xc0, 0x91, 0x35, 0xfb, 0xb1, 0xf9, 0xae,
	0xae, 0x9f, 0x2c, 0x84, 0x91, 0x7a, 0xcf, 0x84, 0xde, 0xa6, 0x7e, 0x34, 0x87, 0xde, 0x11, 0xfa,
	0x5c, 0x69, 0x58, 0xff, 0xaa, 0x50, 0xe4, 0xce, 0xa3, 0x9f, 0x15, 0x58, 0xcb, 0x5e, 0x3d, 0x74,
	0x34, 0x55, 0x43, 0x6e, 0xd8, 0xd6, 0x8f, 0xe7, 0xcc, 0x96, 0x5a, 0x9b, 0x42, 0xeb, 0xa1, 0xbe,
	0x37, 0x5d, 0x6b, 0x24, 0x71, 0xdc, 0xda, 0x3f, 0x14, 0x58, 0xbf, 0xd3, 0x1f, 0xa8, 0x39, 0xf3,
	0x99, 0xf7, 0x8c, 0xb5, 0x16, 0x81, 0x48, 0xad, 0xa7, 0x42, 0xeb, 0xfb, 0xfa, 0xe1, 0x6c, 0xad,
	0x93, 0xb6, 0xb6, 0x5d, 0x98, 0xf6, 0xb7, 0xa1, 0x5d, 0xb5, 0xc5, 0x41, 0x8b, 0xef, 0x2f, 0xf9,
	0xa0, 0xb8, 0x54, 0xbe, 0xac, 0xa4, 0x49, 0x22, 0xe7, 0x37, 0x55, 0xb5, 0x5b, 0xbf, 0xab, 0x3b,
	0x6d, 0xc1, 0xd1, 0x16, 0x1c, 0x29, 0xc4, 0x68, 0x49, 0x8e, 0xee, 0x8a, 0x98, 0x30, 0x27, 0x8f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x9a, 0xf5, 0x74, 0xd0, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FetchClient is the client API for Fetch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FetchClient interface {
	// Resolve or fetch referenced assets, making them available to the caller and
	// other consumers in the [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	//
	// Servers *MAY* fetch content that they do not already have cached, for any
	// URLs they support.
	//
	// Servers *SHOULD* ensure that referenced files are present in the CAS at the
	// time of the response, and (if supported) that they will remain available
	// for a reasonable period of time. The lifetimes of the referenced blobs *SHOULD*
	// be increased if necessary and applicable.
	// In the event that a client receives a reference to content that is no
	// longer present, it *MAY* re-issue the request with
	// `oldest_content_accepted` set to a more recent timestamp than the original
	// attempt, to induce a re-fetch from origin.
	//
	// Servers *MAY* cache fetched content and reuse it for subsequent requests,
	// subject to `oldest_content_accepted`.
	//
	// Servers *MAY* support the complementary [Push][build.bazel.remote.asset.v1.Push]
	// API and allow content to be directly inserted for use in future fetch
	// responses.
	//
	// Servers *MUST* ensure Fetch'd content matches all the specified
	// qualifiers except in the case of previously Push'd resources, for which
	// the server *MAY* trust the pushing client to have set the qualifiers
	// correctly, without validation.
	//
	// Servers not implementing the complementary [Push][build.bazel.remote.asset.v1.Push]
	// API *MUST* reject requests containing qualifiers it does not support.
	//
	// Servers *MAY* transform assets as part of the fetch. For example a
	// tarball fetched by [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory]
	// might be unpacked, or a Git repository
	// fetched by [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob]
	// might be passed through `git-archive`.
	//
	// Errors handling the requested assets will be returned as gRPC Status errors
	// here; errors outside the server's control will be returned inline in the
	// `status` field of the response (see comment there for details).
	// The possible RPC errors include:
	// * `INVALID_ARGUMENT`: One or more arguments were invalid, such as a
	//   qualifier that is not supported by the server.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
	//   perform the requested operation. The client may retry after a delay.
	// * `UNAVAILABLE`: Due to a transient condition the operation could not be
	//   completed. The client should retry.
	// * `INTERNAL`: An internal error occurred while performing the operation.
	//   The client should retry.
	// * `DEADLINE_EXCEEDED`: The fetch could not be completed within the given
	//   RPC deadline. The client should retry for at least as long as the value
	//   provided in `timeout` field of the request.
	//
	// In the case of unsupported qualifiers, the server *SHOULD* additionally
	// send a [BadRequest][google.rpc.BadRequest] error detail where, for each
	// unsupported qualifier, there is a `FieldViolation` with a `field` of
	// `qualifiers.name` and a `description` of `"{qualifier}" not supported`
	// indicating the name of the unsupported qualifier.
	FetchBlob(ctx context.Context, in *FetchBlobRequest, opts ...grpc.CallOption) (*FetchBlobResponse, error)
	FetchDirectory(ctx context.Context, in *FetchDirectoryRequest, opts ...grpc.CallOption) (*FetchDirectoryResponse, error)
}

type fetchClient struct {
	cc *grpc.ClientConn
}

func NewFetchClient(cc *grpc.ClientConn) FetchClient {
	return &fetchClient{cc}
}

func (c *fetchClient) FetchBlob(ctx context.Context, in *FetchBlobRequest, opts ...grpc.CallOption) (*FetchBlobResponse, error) {
	out := new(FetchBlobResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.asset.v1.Fetch/FetchBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetchClient) FetchDirectory(ctx context.Context, in *FetchDirectoryRequest, opts ...grpc.CallOption) (*FetchDirectoryResponse, error) {
	out := new(FetchDirectoryResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.asset.v1.Fetch/FetchDirectory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FetchServer is the server API for Fetch service.
type FetchServer interface {
	// Resolve or fetch referenced assets, making them available to the caller and
	// other consumers in the [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	//
	// Servers *MAY* fetch content that they do not already have cached, for any
	// URLs they support.
	//
	// Servers *SHOULD* ensure that referenced files are present in the CAS at the
	// time of the response, and (if supported) that they will remain available
	// for a reasonable period of time. The lifetimes of the referenced blobs *SHOULD*
	// be increased if necessary and applicable.
	// In the event that a client receives a reference to content that is no
	// longer present, it *MAY* re-issue the request with
	// `oldest_content_accepted` set to a more recent timestamp than the original
	// attempt, to induce a re-fetch from origin.
	//
	// Servers *MAY* cache fetched content and reuse it for subsequent requests,
	// subject to `oldest_content_accepted`.
	//
	// Servers *MAY* support the complementary [Push][build.bazel.remote.asset.v1.Push]
	// API and allow content to be directly inserted for use in future fetch
	// responses.
	//
	// Servers *MUST* ensure Fetch'd content matches all the specified
	// qualifiers except in the case of previously Push'd resources, for which
	// the server *MAY* trust the pushing client to have set the qualifiers
	// correctly, without validation.
	//
	// Servers not implementing the complementary [Push][build.bazel.remote.asset.v1.Push]
	// API *MUST* reject requests containing qualifiers it does not support.
	//
	// Servers *MAY* transform assets as part of the fetch. For example a
	// tarball fetched by [FetchDirectory][build.bazel.remote.asset.v1.Fetch.FetchDirectory]
	// might be unpacked, or a Git repository
	// fetched by [FetchBlob][build.bazel.remote.asset.v1.Fetch.FetchBlob]
	// might be passed through `git-archive`.
	//
	// Errors handling the requested assets will be returned as gRPC Status errors
	// here; errors outside the server's control will be returned inline in the
	// `status` field of the response (see comment there for details).
	// The possible RPC errors include:
	// * `INVALID_ARGUMENT`: One or more arguments were invalid, such as a
	//   qualifier that is not supported by the server.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
	//   perform the requested operation. The client may retry after a delay.
	// * `UNAVAILABLE`: Due to a transient condition the operation could not be
	//   completed. The client should retry.
	// * `INTERNAL`: An internal error occurred while performing the operation.
	//   The client should retry.
	// * `DEADLINE_EXCEEDED`: The fetch could not be completed within the given
	//   RPC deadline. The client should retry for at least as long as the value
	//   provided in `timeout` field of the request.
	//
	// In the case of unsupported qualifiers, the server *SHOULD* additionally
	// send a [BadRequest][google.rpc.BadRequest] error detail where, for each
	// unsupported qualifier, there is a `FieldViolation` with a `field` of
	// `qualifiers.name` and a `description` of `"{qualifier}" not supported`
	// indicating the name of the unsupported qualifier.
	FetchBlob(context.Context, *FetchBlobRequest) (*FetchBlobResponse, error)
	FetchDirectory(context.Context, *FetchDirectoryRequest) (*FetchDirectoryResponse, error)
}

// UnimplementedFetchServer can be embedded to have forward compatible implementations.
type UnimplementedFetchServer struct {
}

func (*UnimplementedFetchServer) FetchBlob(ctx context.Context, req *FetchBlobRequest) (*FetchBlobResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method FetchBlob not implemented")
}
func (*UnimplementedFetchServer) FetchDirectory(ctx context.Context, req *FetchDirectoryRequest) (*FetchDirectoryResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method FetchDirectory not implemented")
}

func RegisterFetchServer(s *grpc.Server, srv FetchServer) {
	s.RegisterService(&_Fetch_serviceDesc, srv)
}

func _Fetch_FetchBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchBlobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetchServer).FetchBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.asset.v1.Fetch/FetchBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetchServer).FetchBlob(ctx, req.(*FetchBlobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetch_FetchDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetchServer).FetchDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.asset.v1.Fetch/FetchDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetchServer).FetchDirectory(ctx, req.(*FetchDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fetch_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.asset.v1.Fetch",
	HandlerType: (*FetchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchBlob",
			Handler:    _Fetch_FetchBlob_Handler,
		},
		{
			MethodName: "FetchDirectory",
			Handler:    _Fetch_FetchDirectory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "build/bazel/remote/asset/v1/remote_asset.proto",
}

// PushClient is the client API for Push service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PushClient interface {
	// These APIs associate the identifying information of a resource, as
	// indicated by URI and optionally Qualifiers, with content available in the
	// CAS. For example, associating a repository url and a commit id with a
	// Directory Digest.
	//
	// Servers *SHOULD* only allow trusted clients to associate content, and *MAY*
	// only allow certain URIs to be pushed.
	//
	// Clients *MUST* ensure associated content is available in CAS prior to
	// pushing.
	//
	// Clients *MUST* ensure the Qualifiers listed correctly match the contents,
	// and Servers *MAY* trust these values without validation.
	// Fetch servers *MAY* require exact match of all qualifiers when returning
	// content previously pushed, or allow fetching content with only a subset of
	// the qualifiers specified on Push.
	//
	// Clients can specify expiration information that the server *SHOULD*
	// respect. Subsequent requests can be used to alter the expiration time.
	//
	// A minimal compliant Fetch implementation may support only Push'd content
	// and return `NOT_FOUND` for any resource that was not pushed first.
	// Alternatively, a compliant implementation may choose to not support Push
	// and only return resources that can be Fetch'd from origin.
	//
	// Errors will be returned as gRPC Status errors.
	// The possible RPC errors include:
	// * `INVALID_ARGUMENT`: One or more arguments to the RPC were invalid.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
	//   perform the requested operation. The client may retry after a delay.
	// * `UNAVAILABLE`: Due to a transient condition the operation could not be
	//   completed. The client should retry.
	// * `INTERNAL`: An internal error occurred while performing the operation.
	//   The client should retry.
	PushBlob(ctx context.Context, in *PushBlobRequest, opts ...grpc.CallOption) (*PushBlobResponse, error)
	PushDirectory(ctx context.Context, in *PushDirectoryRequest, opts ...grpc.CallOption) (*PushDirectoryResponse, error)
}

type pushClient struct {
	cc *grpc.ClientConn
}

func NewPushClient(cc *grpc.ClientConn) PushClient {
	return &pushClient{cc}
}

func (c *pushClient) PushBlob(ctx context.Context, in *PushBlobRequest, opts ...grpc.CallOption) (*PushBlobResponse, error) {
	out := new(PushBlobResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.asset.v1.Push/PushBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushClient) PushDirectory(ctx context.Context, in *PushDirectoryRequest, opts ...grpc.CallOption) (*PushDirectoryResponse, error) {
	out := new(PushDirectoryResponse)
	err := c.cc.Invoke(ctx, "/build.bazel.remote.asset.v1.Push/PushDirectory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushServer is the server API for Push service.
type PushServer interface {
	// These APIs associate the identifying information of a resource, as
	// indicated by URI and optionally Qualifiers, with content available in the
	// CAS. For example, associating a repository url and a commit id with a
	// Directory Digest.
	//
	// Servers *SHOULD* only allow trusted clients to associate content, and *MAY*
	// only allow certain URIs to be pushed.
	//
	// Clients *MUST* ensure associated content is available in CAS prior to
	// pushing.
	//
	// Clients *MUST* ensure the Qualifiers listed correctly match the contents,
	// and Servers *MAY* trust these values without validation.
	// Fetch servers *MAY* require exact match of all qualifiers when returning
	// content previously pushed, or allow fetching content with only a subset of
	// the qualifiers specified on Push.
	//
	// Clients can specify expiration information that the server *SHOULD*
	// respect. Subsequent requests can be used to alter the expiration time.
	//
	// A minimal compliant Fetch implementation may support only Push'd content
	// and return `NOT_FOUND` for any resource that was not pushed first.
	// Alternatively, a compliant implementation may choose to not support Push
	// and only return resources that can be Fetch'd from origin.
	//
	// Errors will be returned as gRPC Status errors.
	// The possible RPC errors include:
	// * `INVALID_ARGUMENT`: One or more arguments to the RPC were invalid.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to
	//   perform the requested operation. The client may retry after a delay.
	// * `UNAVAILABLE`: Due to a transient condition the operation could not be
	//   completed. The client should retry.
	// * `INTERNAL`: An internal error occurred while performing the operation.
	//   The client should retry.
	PushBlob(context.Context, *PushBlobRequest) (*PushBlobResponse, error)
	PushDirectory(context.Context, *PushDirectoryRequest) (*PushDirectoryResponse, error)
}

// UnimplementedPushServer can be embedded to have forward compatible implementations.
type UnimplementedPushServer struct {
}

func (*UnimplementedPushServer) PushBlob(ctx context.Context, req *PushBlobRequest) (*PushBlobResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method PushBlob not implemented")
}
func (*UnimplementedPushServer) PushDirectory(ctx context.Context, req *PushDirectoryRequest) (*PushDirectoryResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method PushDirectory not implemented")
}

func RegisterPushServer(s *grpc.Server, srv PushServer) {
	s.RegisterService(&_Push_serviceDesc, srv)
}

func _Push_PushBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushBlobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServer).PushBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.asset.v1.Push/PushBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServer).PushBlob(ctx, req.(*PushBlobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Push_PushDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServer).PushDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.bazel.remote.asset.v1.Push/PushDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServer).PushDirectory(ctx, req.(*PushDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Push_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.bazel.remote.asset.v1.Push",
	HandlerType: (*PushServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushBlob",
			Handler:    _Push_PushBlob_Handler,
		},
		{
			MethodName: "PushDirectory",
			Handler:    _Push_PushDirectory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "build/bazel/remote/asset/v1/remote_asset.proto",
}
